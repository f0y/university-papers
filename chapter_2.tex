\newpage

\chapter{Реализация}
\label{ch:chapter_2}

\section{Выбор технологий для реализации сетевой архитектуры}

\subsection{Детальная проработка требований}
\label{sec:detailed_requirements}
Существует множество способов установить сетевое взаимодействие между
приложениями, начиная от низкоуровневой обработки пакетов на уровне стека
TCP/IP, заканчивая использованием высокоуровневых объектно-ориентированных
библиотек для протоколов прикладного уровня. Был сформирован ряд ограничений
(см. главу \ref{sec:problem_statement}), которых необходимо придерживаться при
выборе технологии для построения сетевой архитектуры.

В соответствии с концепцией сетевого взаимодействия (см. главу
\ref{sec:collaborative_mindmapping}), мы имеем клиент-серверную архитектуру.
Взаимодействие пользователей будет более удобным, если сервер можно будет
создавать на любом устройстве и в любой момент времени. Взаимодействие должно
выглядеть следующим образом: пользователь создаёт сервер, другие участники
подсоединяются к нему и начинают редактирование. Каждое изменение, сделанное
участником, отправляется на сервер, который рассылает это изменение всем другим
участникам (см. рис. \ref{img:users_collaboration_example}).

\begin{figure}[!h]
  \centering
  \includegraphics[width=\linewidth]{users_collaboration_example.pdf}
  \caption{Взаимодействие клиентов и сервера}
  \label{img:users_collaboration_example}
\end{figure} 

Проект HiveMind поддерживает мобильные устройства и настольные компьютеры (см.
главу \ref{sec:project_summary}), имеющие различный способ подключения к
интернету. У каждого из этих способов есть свои преимущества и
недостатки. Пользователи настольных компьютеров, как правило, имеют широкий
канал интернет соединения, в отличие от пользователей мобильных устройств.
Мобильные устройства способны подключаться к интернету почти везде и в любое
время. В связи с нехваткой IPv4 адресов, операторы мобильной связи назначают
серые ip адреса мобильным устройствам, что делает данные устройства недоступными
напрямую из сети Интернет. Соединение по беспроводным сетям зачастую нестабильно
и иногда вызывает значительные задержки при передачи данных. Пользователи
настольных компьютеров могут использовать NAT или фаервол блокирующий
входящие соединения. В корпоративной среде, пользователи зачастую ограничены
HTTP прокси, как единственным способом доступа в сеть Интернет.

Подводя итог всем вышеперечисленным особенностям, был сформирован список
требований для выбираемой технологии промежуточного слоя.
\begin{itemize}
\item Взаимодействие основанное на клиент-серверной модели.
\item Сервер должен иметь поддержку подписки.
\item Пользователь может иметь медленное, ненадежное соединение до
сети Интернет, расположенное за NAT.
\item Не должно быть сложностей в создании сервера.
\item Выбранная технология должна поддерживаться библиотекой на языке
Python.
\end{itemize}

\subsection{Преимущества протокола XMPP}

XMPP (Extensible Messaging and Presence Protocol) "--- расширяемый протокол для
обмена сообщениями, в режиме близком к режиму реального времени. Протокол XMPP
может быть рассмотрен на нескольких уровнях абстракции. На нижнем уровне
абстракции, существует клиентское приложение, использующее протокол XMPP,
которое подключается к серверу и обменивается с ним сообщениями. Соединение с
сервером может быть установлено несколькими способами, даже поверх протокола
HTTP. На высоком уровне абстракции, клиент получает доступ ко всей XMPP сети,
где каждый её узел имеет уникальный идентификатор, называемый JID (Jabber
Identificator). Преимуществом является то, что пересылка сообщений между узлами
сети не требует дополнительных усилий. Клиент создаёт сообщение, адресованное
другому клиенту и посылает его на сервер, который отвечает за все операции,
связанные с доставкой данного сообщения.

Большое преимущество протокола XMPP "--- расширяемость. Он может быть расширен с
помощью расширяющих протоколов (XEP). XMPP является открытым протоколом и каждый
желающий может создать высокоуровневый протокол поверх него. Организация XMPP
Standards Foundation отвечает за процесс создания и поддержки данных протоколов.
Существует расширение XEP-0060 Publish-Subscribe \cite{xep-0060}. Оно отвечает
за то, как реализовывать сервис публикации/подписки поверх протокола XMPP. Любой
участник XMPP сети может создать сервис публикации/подписки.

XMPP был создан как протокол мгновенного обмена сообщениями, использующий XML
для формирования сообщений. XML создаёт избыточную информацию и его
использование может потребовать широкой полосы Интернет соединения. Но сообщения
между клиентом и сервером могут быть сжаты с использованием расширение XEP-0138
(Stream Compression extension). Таким образом, протокол XMPP может быть избавлен
от вышеназванного недостатка.

В настоящее время существует множество общедоступных XMPP серверов
поддерживающих общение в чате. Участие в подобных чатах доступно с мобильных
устройств и не требует широкополосного доступа в Интернет. С технической точки
зрения, совместное редактирование диаграмм очень похоже на участие в чате из
чего следует, что объём трафика не будет сильно отличаться. Исключением является
устройство, являющееся сервером. Данному устройству будет необходим более
широкий канал до сети Интернет для взаимодействия со многими клиентами.

Протокол XMPP c расширением публикации/подписки удовлетворяет требованиям к 
технологии промежуточного слоя (см. главу \ref{sec:detailed_requirements}). 
Он позволяет избежать почти все сложности связанные с реализацией 
клиент-серверной архитектуры и с точки зрения данных требований не имеет 
недостатков, поэтому он был выбран технологией промежуточного слоя.

\subsection{Выбор библиотеки для работы с XMPP протоколом}
Следующей задачей является выбор библиотеки языки Python, поддерживающей
расширение XEP-0060. На сайте XMPP Foundation \cite{xmpp} есть список из
восьми библиотек поддерживающих XMPP. Некоторые библиотеки более не
поддерживаются (jabber.py), некоторые требуют использования более новых (2.6,
3.x) версий языка Python, недоступных под платформой Maemo (pyxmpp), другие же
являются исследовательскими проектами и не предназаначены для повсеместного
использования (SleekXMPP). Twisted "--- единственный инструмент для работы с
XMPP протоколом, доступный в репозитории Maemo.

Twisted "--- событийно-ориентированный сетевой фрэймворк, поддерживающий
множество протоколов таких как: TCP, UDP, SSL/TLS, HTTP, XMPP, NNTP, IMAP, SSH,
IRC, FTP и множество других \cite{twisted}. Twisted не имеет встроенной
поддержки XEP-0060, но существует внешняя библиотека Wokkel \cite{wokkel},
поддерживающая данное расширение. Данная библиотека отсутствует в репозитории
Maemo. Для того, чтобы иметь возможность её использовать, было принято решение о
создании и поддержки пакета для платформы Maemo.

\section{Архитектура сетевой подсистемы}
\subsection{XMPP расширение публикации/подписки}
Расширение XEP-0060 использует шаблон проектирования ``publish-subscribe'',
являющийся более общим относительно шаблона ``observer''. Данный шаблон состоит
в следующем: человек или приложение публикует информацию, после чего уведомление
о данном событии (с опубликованной иноформацией или без) пересылается всем
подписчикам. В общем случае, взаимодействие между подписчиками и публикующими
контролируется сервером, который получает запрос на публикацию и производит
рассылку уведомлений всем подписчикам.

Сервер может поддерживать подписку на различные сущности. В терминах расширения
XEP-0060, данные сущности называются ``узлами (nodes)''. Каждый подобный узел
имеет собственный список подписчиков. Узлы также могут хранить историю всех
уведомлений и обеспечивать другие сервисы определённые стандартом. Данные
получаемые сервером и пересылаемые на него называются ``элементом (item)''.
Описанная система организации данных может быть ассоциирована с организацией
файловой системы, где узлы представляют директории, а элементы соотносятся как
файлы.

В терминах XMPP расширения публикации/подписки процесс взаимодействия может быть
представлен следующим образом. Пользователь создаёт сервер с единственным узлом
для обмена и хранения сообщений. Другие участники подписываются на обновления от
созданного узла. Когда кто-нибудь из публикующих делает изменения, они
пересылаются на сервер, который уведомляет всех подписчиков о произошедшем
событии. Данные пересылаются, используя возможности элемента содержать в себе
полезную нагрузку. Имея данную схему в голове, была начата детальная проработка
сетевой архитектуры, учитывая архитектуру существующего приложения.

\subsection{Распространение изменений}
\label{sec:changeset_propagation}
HiveMind имеет возможности undo/redo, как и любой хороший редактор. Данная
функциональность реализована поверх QUndoStack, который хранит всю историю
выполненных команд. Каждое изменение на диаграмме связи атомарно. Когда
пользователь совершает изменение создаётся QUndoCommand. В QUndoCommand хранится
информация для выполнения команды и для её отката. Таким образом использование
QUndoStack позволяет двигаться по всей истории изменений. Для каждого типа
данных команд были созданы функции сериализации и десериализации в XML.
Изменения сделанные на карте отправляются на сервис в виде XML сериализованных
сообщений и не сохраняются в стеке команд. Команды добавляются в стек только
если они пришли как уведомления от сервиса, поэтому подписчик должен ждать
ответа от сервера для того чтобы увидеть выполненные изменения (см рис.
~\ref{img:changeset_propagation}).

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{changeset-propagation.pdf}
  \caption{Диаграмма распространения изменений}
  \label{img:changeset_propagation}
\end{figure}

Для того чтобы управлять данным асинхронным взаимодействием был добавлен класс
NetworkController. Все команды поступают в сетевой контроллер. Если сетевое
взаимодействие неактивно, комманда добавляется в стек комманд. В противном
случае данная команда будет сериализована и отправлена на сервис. Уведомления
пришедшие от сервиса десериализуются в команды, добавляются в стек команд и
выполняются.

Данные команды содержат в себе информацию лишь об изменившейся части диаграммы.
Данное условие необходимо, чтобы уменьшить объём пересылаемых данных, который в
противном случае будет чрезмерно большим. Для того чтобы пересланная команда
выполнялась корректно у всех участников, необходимо чтобы они имели одинаковые
копии диаграмм. Поэтому встаёт вопрос о распространении и синхронизации
исходной диаграммы связи.

Проблема распространения диаграммы решается слеудующим образом: первый элемент в
узле должен содержать в себе сериализованную диаграмму связей. Все остальные
элементы содержат в себе сериализованные команды изменений. Когда участник
становится авторизованным подписчиком ему пересылаются все элементы содержащиеся
в узле, включая диаграмму и совершенные ранее изменения.

Синхронизация диаграммы связей между всеми участниками представляет более
сложную проблему. Фактически речь идёт о сохранение целостности диаграммы связи,
то есть контроле поступающих изменений. При поступлении некорректного изменения,
сервер должен отбросить изменение или провести слияние изменений, если возможно.
К примеру, из-за задержек в соединении пользователь может изменить узел, который
уже удалён одним из участников. В таком случае сервер должен отослать
пользователю уведомление об ошибке и отбросит некорректное изменение.

Подписчик может запросить все данные или часть данных, хранящихся в узле, в
любой момент времени. Данная возможность используется для синхронизации
локальной копии диаграммы в случае если изменение было отброшено сервером.
Сервер не нуждается в дополнительных способах синхронизации диаграммы, поскольку
все изменения локальны и всегда являются актуальными и корректными.

\section{Реализация сетевой подсистемы}
Сетевая подсистема приложения была реализована поверх фрэймворка Twisted и
библиотеки Wokkel. Wokkel является надстройкой над Twisted, добавляющей
фрэймворку дополнительную функциональность. В частности он предоставляет
средства для более удобной реализации XMPP расширений (XEP) и имеет поддержку
следующих: Service Discovery (XEP-0030), Publish-Subscribe (XEP-0060).
Реализация расширения публикации/подписки в Wokkel не содержит бизнес-логики.
Это значит, что он отвечает за приём, генерацию и отправку сообщений в
соответствии со спецификацией XEP-0060. Wokkel реагирует на события, относящиеся
к публикации/подписке, делает разбор пришедших сообщений и вызывает
соответствующие обработчики.

Расширение публикации/подписки является одним из самых больших и сложных.
Правильная реализация необходимого функционала может занять большое количество
времени. Поэтому было принято решение использовать библиотеку Idavoll. Данная
библиотека реализована поверх Wokkel и реализует функциональность XEP-0060
необходимую для приложения, такую как: ``Подписка'', ``Публикация'', ``Создание
узлов'', ``Хранилище элементов''. Также она имеет хорошую архитектуру,
позволяющую добавлять реализацию новой функциональности, определенной стандартом
расширения публикации/подписки. Idavoll имеет множество классов необходимых для
реализации спецификации XEP-0060 (см. рис. ~\ref{img:network_classes}).

Класс Node является абстрактным классом и представляют собой узел в терминах
XEP-0060. Существуют два типа узлов: LeafNode и CollectionNode. LeafNode может
содержать только элементы, когда как CollectionNode может содержать лишь другие
узлы. LeafNode хранит элементы в виде простого списка, но это не является
подходящим решением для приложения. Как было сказано в главе
~\ref{sec:changeset_propagation}, необходимо проверять приходящие изменения на
корректность. Для этого был создан класс Changeset, хранящий в себе информацию о
самом изменении, его типе, времени создания и авторе данного изменения. Также
создан специальный класс-контейнер СhangesetStack, хранящий экземпляры класса
Changeset и отвечающий за корректность и согласованность изменений находящихся в
нём. HivemindNode унаследован от LeafNode и в отличии от него хранит изменения в
ChangesetStack.

BackendService содержит реализацию бизнес-логики XEP-0060. В нем содержится
логика для работы с подписчиками, проверка прав доступа и т.д. Он связан
отношением композиции с классом Storage, отвечающим за управление узлами
(создание, удаление, конфигурирование). Класс HivemindNode, создаётся классом
Storage и содержит в себе методы для добавления данных, изменения конфигурации
узла, списка подписчиков и их ролей. PubSubService является классом библиотеки
Wokkel отвечающий за разбор пришедших сообщений и вызов соответствующих методов.
Если он содержит в себе экземпляр класса PubSubResourceFromBackend, то помимо
вызова своих обработчиков, осуществляется передача уже разобранных сообщений в
подходящие методы класса PubSubResourceFromBackend. Этот класс является
дополнительным уровнем абстракции, что позволяет делать архитектуру более
гибкой. PubSubResourceFromBackend обязательно содержит экземпляр класса
BackendService, которому он делегирует реализацию бизнес-логики.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{idavoll-classes.pdf}
  \caption{Диаграмма сетевых классов}
  \label{img:network_classes}
\end{figure}

Мобильные устройства зачастую имеют нестабильное соединение с сетью Интернет,
поэтому приложение должно иметь механизм, позволяющий обнаружить, что соединение
потеряно и уведомить об этом пользователя. Механизм проверки осуществляется
посредством XMPP Ping (XEP-0199) \cite{xep-0199}. Класс Pinger
ответственен за отсылку пинг сообщений и приём ответов. Проверка осуществляется
следующим образом: данный класс непрерывно отсылает пинг сообщения на XMPP
сервер, к которому подключен пользователь, если достигнуто определенное
количество пинг соббщений, оставшихся без ответа, то соединение рассматривается
как потерянное.

Похожий механизм используется для проверки статуса подписчиков. Каждый
подписчик имеет свой экземпляр класса Pinger, который отвечает за отсылку пинг
сообщений именно ему. На клиентской стороне реализован обработчик, который
отвечает на приходящие пинг сообщения от сервера приложения. Подписчиков может
быть очень много, поэтому был создан класс PingManager, отвечающий за управление
экземплярами класса Pinger (см. рис. ~\ref{img:ping_manager}). Он
создаёт и удаляет экземпляры класса Pinger, а также запускает или останавливает
отправку пинг сообщений до адресата. Pinger уведомляет NetworkController о
состоянии соединения с XMPP сервером, а также со всеми подписчиками.
Пользователь может увидеть статус соединения с подписчиками в диалоге
редактирования прав доступа(см. рис. ~\ref{img:permissions_dialog})

\begin{figure}
  \centering
  \includegraphics[scale=1.2]{ping-manager.pdf}
  \caption{Диаграмма классов, отвечающих за проверку состояния соединений}
  \label{img:ping_manager}
\end{figure}


\section{Система контроля доступа}
По умолчанию, все участники совместной работы имеют одинаковый доступ к 
редактированию диагаммы связей. Такое поведение является подходящим для 
случаев, когда необходимо создать множество идей или найти решение сложной 
проблемы. Но существуют сценарии совместной работы, описанные в пункте ~\ref
{sec:collaborative_mindmapping}, при которых необходимо ограничить права 
доступа некоторых пользователей. Для того, чтобы была возможность 
взаимодействия по подобным сценариям, в HiveMind была реализована система 
контроля доступа.

Стандарт XEP-0060 заложена фукциональность называемая моделью доступа (access model), которая может быть сопоставлена с системой аутентификации. Пользователь, открывающий доступ к диаграмме, может установить уровень доверия для новых участников. Это значит, что пользователь может ограничить круг лиц, имеющих право на присоединение к совместной работе. Было реализовано четыре модели доступа:
\begin{itemize}
\item ``Открытая (open)'' --- поведение по умолчанию,  любой может присоединиться;
\item ``Контакт лист (roster)'' --- только лица, находящиеся в контакт листе владельца сервера;
\item ``Интерактивная (authorize)'' --- владелец может выбирать тех, кто имеет право на участие в совместной работе. Когда очередной человек подключается к диаграмме, владелец получает запрос на присоединение;
\item ``Белый список(whitelist)'' --- новый участник может присоединиться, лишь в том случае, если он находится в белом списке владельца сервера.
\end{itemize}

Следующая часть системы контроля доступа приложения HiveMind, также является частью стандарта XEP-0060 и называется affiliations. Данная функциональность отвечает за авторизацию пользователей. Каждый участник, присоединившийся к диаграмме, имеет свою роль, определяющую набор допустимых действий. Было реализовано четыре роли: 
\begin{itemize}
\item ``Изгнанник(outcast)'' --- не имеет права присоединяться и участвовать в совместной работе;
\item ``Участник(member)'' --- имеет право только получать данные;
\item ``Издатель(publisher)'' --- имеет право получать и публиковать данные;
\item ``Владелец(owner)'' ---  имеет права издателя и может дополнительно конфигурировать все аспекты сетевого взаимодействия.
\end{itemize}
Владелец сервера может в любой момент изменить роль человека, используя диалог управления правами доступа (см. рис. ~\ref{img:permissions_dialog}).

\begin{figure}[b] 
  \centering
  \includegraphics[width=0.5\linewidth]{permissions_dialog.png}
  \caption{Диалог управления правами доступа}
  \label{img:permissions_dialog}
\end{figure}

XEP-0060 предоставляет возможность сделать систему контроля доступа еще более 
гибкой. В некоторых случаях, может возникнуть необходимость временно 
позволить всем участникам  редактировать диаграмму. Для этого можно изменить 
роли всех участников на издателя, что в случае большого количества участников 
является утомительным и долгим занятием. Выходом из данной ситуации является 
реализация функциональности publish model, опеределенной стандартом XEP-0060. 
Данный механизм определяет, кто имеет право вносить изменения на диаграмму 
связей. В первом случае, это участники имеющие роль издателя, а в другом, все 
участники имеют право изменять диаграмму.

Реализация системы контроля доступа позволила значительно увеличить 
количество сценариев совместного взаимодействия. Данная система может быть 
улучшена, чтобы увеличить количество областей применения приложения. Одной из 
подобных областей является проведение презентаций, а точнее взаимодействие 
докладчика и слушателей. В пункте ~\ref{sec:collaborative_mindmapping} был 
представлен сценарий проведения презентации. Данный сценарий может расширен 
следующим образом: позволить слушателям добавлять свои вопросы и пожелания на 
диаграмму докладчика. В таком случае, необходимо, чтобы слушатели не могли 
изменять узлы созданные докладчиком или другими слушателями, за что и будет 
отвечать система контроля доступа.  
