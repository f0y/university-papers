\newpage

\chapter{Реализация}
\label{ch:chapter_2}

\section{Выбор технологий для реализации сетевой архитектуры}

\subsection{Детальная проработка требований}
\label{sec:detailed_requirements}
Существует множество способов установить сетевое взаимодействие между
приложениями, начиная от низкоуровневой обработки пакетов на уровне стека
TCP/IP, заканчивая использованием высокоуровневых объектно-ориентированных
библиотек для протоколов прикладного уровня. Был сформирован ряд ограничений
(см. главу \ref{sec:problem_statement}), которых необходимо придерживаться при
выборе технологии для построения сетевой архитектуры.

В соответствии с концепцией сетевого взаимодействия (см. главу
\ref{sec:collaborative_mindmapping}), мы имеем клиент-серверную архитектуру.
Взаимодействие пользователей будет более удобным, если сервер можно будет
создавать на любом устройстве и в любой момент времени. Взаимодействие должно
выглядеть следующим образом: пользователь создаёт сервер, другие участники
подсоединяются к нему и начинают редактирование. Каждое изменение, сделанное
участником, отправляется на сервер, который рассылает это изменение всем другим
участникам (см. рис. \ref{img:users_collaboration_example}). Для надежного
сообщения между клиентами и сервером, все участники должны иметь одинаковую и верную копию карты.

\begin{figure}[!h]
  \centering
  \includegraphics[width=\linewidth]{users_collaboration_example.pdf}
  \caption{Взаимодействие клиентов и сервера}
  \label{img:users_collaboration_example}
\end{figure} 

Проект HiveMind поддерживает мобильные устройства и настольные компьютеры (см.
главу \ref{sec:project_summary}), имеющие различный способ подключения к
интернету. У каждого из этих способов есть свои преимущества и
недостатки. Пользователи настольных компьютеров, как правило, имеют широкий
канал интернет соединения, в отличие от пользователей мобильных устройств.
Мобильные устройства способны подключаться к интернету почти везде и в любое
время. В связи с нехваткой IPv4 адресов, операторы мобильной связи назначают
серые ip адреса мобильным устройствам, что делает данные устройства недоступными
напрямую из сети Интернет. Соединение по беспроводным сетям зачастую нестабильно
и иногда вызывает значительные задержки при передачи данных. Пользователи
настольных компьютеров могут использовать NAT или фаервол блокирующий
входящие соединения. В корпоративной среде, пользователи зачастую ограничены
HTTP прокси, как единственным способом доступа в сеть Интернет.

Подводя итог всем вышеперечисленным особенностям, был сформирован список
требований для выбираемой технологии промежуточного слоя.
\begin{itemize}
\item Взаимодействие основанное на клиент-серверной модели.
\item Сервер должен иметь поддержку подписки.
\item Пользователь может иметь медленное, ненадежное соединение до
сети Интернет, расположенное за NAT.
\item Не должно быть сложностей в создании сервера.
\item Выбранная технология должна поддерживаться библиотекой на языке
Python.
\end{itemize}

\subsection{Преимущества протокола XMPP}

XMPP (Extensible Messaging and Presence Protocol) "--- расширяемый протокол для
обмена сообщениями, в режиме близком к режиму реального времени. Протокол XMPP
может быть рассмотрен на нескольких уровнях абстракции. На нижнем уровне
абстракции, существует клиентское приложение, использующее протокол XMPP,
которое подключается к серверу и обменивается с ним сообщениями. Соединение с
сервером может быть установлено несколькими способами, даже поверх протокола
HTTP. На высоком уровне абстракции, клиент получает доступ ко всей XMPP сети,
где каждый её узел имеет уникальный идентификатор, называемый JID (Jabber
Identificator). Преимуществом является то, что пересылка сообщений между узлами
сети не требует дополнительных усилий. Клиент создаёт сообщение, адресованное
другому клиенту и посылает его на сервер, который отвечает за все операции,
связанные с доставкой данного сообщения.

Большое преимущество протокола XMPP "--- расширяемость. Он может быть расширен с
помощью расширяющих протоколов (XEP). XMPP является открытым протоколом и каждый
желающий может создать высокоуровневый протокол поверх него. Организация XMPP
Standards Foundation отвечает за процесс создания и поддержки данных протоколов.
Существует расширение XEP-0060 Publish-Subscribe \cite{xep-0060}. Оно отвечает
за то, как реализовывать сервис публикации/подписки поверх протокола XMPP. Любой
участник XMPP сети может создать сервис публикации/подписки.

XMPP был создан как протокол мгновенного обмена сообщениями, использующий XML
для формирования сообщений. XML создаёт избыточную информацию и его
использование может потребовать широкой полосы Интернет соединения. Но сообщения
между клиентом и сервером могут быть сжаты с использованием расширение XEP-0138
(Stream Compression extension). Таким образом, протокол XMPP может быть избавлен
от вышеназванного недостатка.

В настоящее время существует множество общедоступных XMPP серверов
поддерживающих общение в чате. Участие в подобных чатах доступно с мобильных
устройств и не требует широкополосного доступа в Интернет. С технической точки
зрения, совместное редактирование диаграмм очень похоже на участие в чате из
чего следует, что объём трафика не будет сильно отличаться. Исключением является
устройство, являющееся сервером. Данному устройству будет необходим более
широкий канал до сети Интернет для взаимодействия со многими клиентами.

XMPP protocol was created as an instant messaging protocol. It is convenient to
exchange human-readable messages in human-readable format. For the sake of
interoperability it uses XML-based structures for message formatting. Протокол
XMPP c расширением публикации/подписки удовлетворяет требованиям к технологии
промежуточного слоя (см. главу \ref{sec:detailed_requirements}). Он позволяет
избежать почти все сложности связанные с реализацией клиент-серверной
архитектуры и с точки зрения данных требований не имеет недостатков, поэтому он
был выбран технологией промежуточного слоя.

\subsection{Выбор библиотеки для работы с XMPP протоколом}
Следующей задачей является выбор библиотеки языки Python, поддерживающей
расширение XEP-0060. На сайте the XMPP Foundation \cite{xmpp} есть список из
восьми библиотек поддерживающих XMPP. Некоторые библиотеки более не
поддерживаются (jabber.py), некоторые требуют использования более новых (2.6,
3.x) версий языка Python, недоступных под платформой Maemo (pyxmpp), другие же
являются исследовательскими проектами и не предназаначены для повсеместного
использования (SleekXMPP). Twisted "--- единственный инструмент для работы с
XMPP протоколом, доступный в репозитории Maemo.

Twisted "--- событийно-ориентированный сетевой фрэймворк, поддерживающий
множество протоколов таких как: TCP, UDP, SSL/TLS, HTTP, XMPP, NNTP, IMAP, SSH,
IRC, FTP и множество других \cite{twisted}. Twisted не имеет встроенной
поддержки XEP-0060, но существует внешняя библиотека Wokkel \cite{wokkel},
поддерживающая данное расширение. Данная библиотека отсутствует в репозитории
Maemo. Для того, чтобы иметь возможность её использовать, было принято решение о
создании и поддержки пакета для платформы Maemo.

\section{Архитектура сетевой подсистемы}
\subsection{XMPP расширение публикации/подписки}
Расширение XEP-0060 использует шаблон проектирования ``publish-subscribe'',
являющийся более общим относительно шаблона ``observer''. Данный шаблон состоит
в следующем: человек или приложение публикует информацию, после чего уведомление
о данном событии (с опубликованной иноформацией или без) пересылается всем
подписчикам. В общем случае, взаимодействие между подписчиками и публикующими
контролируется сервером, который получает запрос на публикацию и производит
рассылку уведомлений всем подписчикам.

Сервер может поддерживать подписку на различные сущности. В терминах расширения
XEP-0060, данные сущности называются ``узлами (nodes)''. Каждый подобный узел
имеет собственный список подписчиков. Узлы также могут хранить историю всех
уведомлений и обеспечивать другие сервисы определённые стандартом. Данные
получаемые сервером и пересылаемые на него называются ``элементом (item)''.
Описанная система организации данных может быть ассоциирована с организацией
файловой системы, где узлы представляют директории, а элементы соотносятся как
файлы.

В терминах XMPP расширения публикации/подписки процесс взаимодействия может быть
представлен следующим образом. Пользователь создаёт сервер с единственным узлом
для обмена и хранения сообщений. Другие участники подписываются на обновления от
созданного узла. Когда кто-нибудь из публикующих делает изменения, они
пересылаются на сервер, который уведомляет всех подписчиков о произошедшем
событии. Данные пересылаются, используя возможности элемента содержать в себе
полезную нагрузку. Имея данную схему в голове, была начата детальная проработка
сетевой архитектуры, учитывая архитектуру существующего приложения.

\subsection{Распространение изменений}
HiveMind имеет возможности undo/redo, как и любой хороший редактор. Данная
функциональность реализована поверх QUndoStack, который хранит всю историю
выполненных команд. Каждое изменение на диаграмме связи атомарно. Когда
пользователь совершает изменение создаётся QUndoCommand. В QUndoCommand хранится
информация для выполнения команды и для её отката. Таким образом использование
QUndoStack позволяет двигаться по всей истории изменений. Для каждого типа
данных команд были созданы функции сериализации и десериализации в XML.
Изменения сделанные на карте отправляются на сервис в виде XML сериализованных
сообщений и не сохраняются в стеке команд. Команды добавляются в стек только
если они пришли как уведомления от сервиса, поэтому подписчик должен ждать
ответа от сервера для того чтобы увидеть выполненные изменения (см рис.
~\ref{img:changeset_propagation}).

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{changeset-propagation.pdf}
  \caption{Диаграмма распространения изменений}
  \label{img:changeset_propagation}
\end{figure}

Для того чтобы управлять данным асинхронным взаимодействием был добавлен класс
NetworkController. Все команды поступают в сетевой контроллер. Если сетевое
взаимодействие неактивно, комманда добавляется в стек комманд. В противном
случае данная команда будет сериализована и отправлена на сервис. Уведомления
пришедшие от сервиса десериализуются в команды, добавляются в стек команд и
выполняются.

Данные команды содержат в себе информацию лишь об изменившейся части диаграммы.
Данное условие необходимо, чтобы уменьшить объём пересылаемых данных, который в
противном случае будет чрезмерно большим. Для того чтобы пересланная команда
выполнялась корректно у всех участников, необходимо чтобы они имели одинаковые
копии диаграмм. Поэтому встаёт вопрос о распространении и синхронизации
исходной диаграммы связи.

Проблема распространения диаграммы решается слеудующим образом: первый элемент в
узле должен содержать в себе сериализованную диаграмму связей. Все остальные
элементы содержат в себе сериализованные команды изменений. Когда участник
становится авторизованным подписчиком ему пересылаются все элементы содержащиеся
в узле, включая диаграмму и совершенные ранее изменения.

Синхронизация диаграммы связей между всеми участниками представляет более
сложную проблему. Фактически речь идёт о сохранение целостности диаграммы связи,
то есть контроле поступающих изменений. При поступлении некорректного изменения,
сервер должен отбросить изменение или провести слияние изменений, если возможно.
К примеру, из-за задержек в соединении пользователь может изменить узел, который
уже удалён одним из участников. В таком случае сервер должен отослать
пользователю уведомление об ошибке и отбросит некорректное изменение.

Подписчик может запросить все данные или часть данных, хранящихся в узле, в
любой момент времени. Данная возможность используется для синхронизации
локальной копии диаграммы в случае если изменение было отброшено сервером.
Сервер не нуждается в дополнительных способах синхронизации диаграммы, поскольку
все изменения локальны и всегда являются актуальными и корректными.

\section{Реализация архитектуры сетевой подсистемы}

Network subsystem of HiveMind is implemented on top of Twisted \cite{twisted} and
Wokkel \cite{wokkel}. Twisted is a framework for writing asynchronous,
event-driven network applications in Python. It has additional support for many
GUI frameworks like Qt, GTK, Tk, and others.

Wokkel library is a pack of enhancements for Twisted. Particularly, Wokkel
provides a mechanism for easier implementation of XMPP Enhancement Protocols
(XEP). It supports for Service Discovery (XEP-0030), Publish-Subscribe
(XEP-0060) and other XEPs. Implementation of XEP-0060 does not contain business
logic. It means that Wokkel responds for receiving and generating XMPP requests
according to XEP-0060 specification. Wokkel reacts on external pub/sub events
and invokes corresponding methods.

XEP-0060 is very large and complicated. Implementation of all features,
necessary for HiveMind, would take lots of time. Idavoll library is built on top
of Wokkel and provides implementations of many XEP-0060 features such as
``Subscribing'', ``Publishing'', ``Persistent items'', ``Node creation'' and
etc.

Idavoll has many classes needed to implement XEP-0060 specification (see
fig.~\ref{img:network_classes}). Node class represents a XEP-0060 node. There are
two node types: Leaf and Collection. A leaf node contains a published item,
whereas a collection node contains other nodes.

% Для этого был создан класс
% Changeset, хранящий в себе информацию о самом изменении, его типе,
% времени создания и авторе данного изменения. Также создан специальный
% класс-контейнер СhangesetStack, хранящий экземпляры класса Changeset и
% отвечающий за согласованность изменений находящихся в нём

HivemindNode class inherits LeafNode, but stores the published items in
ChangesetStack instead of a simple list. Using of ChangesetStack allows to check
integrity and correctness of data. Storage class responds for managing all nodes
on the service. BackendService is an implementation of XEP-0060 business logic.
PubSubServiceFromBackend inherits Wokkel's PubSubService class. It invokes
methods for handling corresponding XMPP requests and delegates action performing
to BackendService class.
%---------------------------
Mobile devices often have unstable internet connection, so the user have to be
notified when XMPP session is lost. We check connection using XEP-0199 (XMPP
Ping) \cite{ping-xep-0199}. PingClientProtocol class sends ping to the XMPP
server and waits for reply. If there is a certain number of failed pings, the
connection is considered as lost.

The similar mechanism is used for checking participation status of a person. On
the service each participant has his/her own instance of PingClientProtocol. Ping
handler on the client side replies only to the service which it is connected
to. We implemented PingManager class to manage multiple instances of
PingClientProtocol (see fig.~\ref{img:ping_manager}).  It creates/deletes instances
and starts/stops ping to the certain entity. PingClientProtocol class is
responsible for notifying NetworkController about participant status, which is
shown to the service owner (see fig.~\ref{img:permissions_dialog}).

\begin{figure}
\begin{minipage}[t]{0.64\linewidth}
  \center{\includegraphics[width=\linewidth]{idavoll-classes.pdf}}
  \caption{Диаграмма сетевых классов}
  \label{img:network_classes}
\end{minipage}
\hfill
\begin{minipage}[t]{0.35\linewidth}
  \center{\includegraphics[scale=0.8]{ping-manager.pdf}}
  \caption{Диаграмма классов, отвечающих за проверку состояния соединений}
  \label{img:ping_manager}
\end{minipage}
\end{figure}


\section{Система контроля доступа}

By default, all participants of teamwork have equal permissions to contribute to
the mind map. It is quite convenient for brainstorming-like activities when the
purpose of the collaboration is to generate some materials or to find a solution
for a long-standing problem. This kind of behavior looks unsuitable for other
use cases. Sometimes it is useful to restrict access for particular users in
order to prevent accidental interference of teamwork. To take such scenarios
into account we introduced access control system to HiveMind.

XEP-0060 provides a feature, named Access Model, which can be associated with
authentication system. The user, who creates the mind map, can set trust level
for all new participants i.e. control who can participate in collaboration.
There are four access models implemented in HiveMind:
\begin{itemize}
\item ``Open'' --- any person may join collaboration;
\item ``Roster'' --- only contacts from the owner’s roster may join;
\item ``Authorize'' --- the owner choose who may join on the fly. When a new
  person is connected, the owner gets a participation request from the person;
\item ``Whitelist'' --- a person may join only if he/she is in the owner’s
  whitelist.
\end{itemize}

``Affiliations'' is the next feature, defined in XEP-0060, being a part of
HiveMind access control system. This feature provides authorization capabilities
to XEP-0060. After the person joined collaboration, he/she has a role, which
determines a set of allowed actions. There are four roles implemented in
HiveMind:
\begin{itemize}
\item ``Outcast'' --- person not allowed to join collaboration i.e. in terms of
  IM he/she is banned;
\item ``Member'' --- person allowed to receive items;
\item ``Publisher'' --- person allowed to publish and receive items;
\item ``Owner'' --- similar to the Publisher, but allowed to configure
  collaboration behaviour.
\end{itemize}
Service owner can edit role of desired person at any time with the use of
permissions dialog (fig.~\ref{img:permissions_dialog}).

\begin{figure}[b] 
  \centering
  \includegraphics[width=0.5\linewidth]{permissions_dialog.png}
  \caption{Диалог управления правами доступа}
  \label{img:permissions_dialog}
\end{figure}

XEP-0060 has features that makes access control even more flexible. In some
cases it might be useful to temporarily assign publisher role to all
participants. HiveMind has implementation of XEP-0060 feature named Publish
Model. It determines two cases of who is allowed to make changes to the
mindmap. In the first case it is a person whose affiliation is publisher, and in
the second case any participant is allowed to post changes.

Impelementation of access control system helps us to discover new use cases of
HiveMind. Presentation using HiveMind is one of such use cases. First of all,
lecturer can control who may join the presentation. Secondly, there are can be
more than one lecturer. Presentations using HiveMind distinguish from
collaborative editing: lecturer's current node and fold/unfold events must be
propagated through the network. This ensured that participants can track the
presentation movement.
 
Authorization system can be extended to greatly improve presentation
support. For example, lecturer may want to receive questions. Participants
can add nodes containing a questions or suggestions to lecturer mindmap.
Authorization system controls interaction between lecturer and participants e.g.
participant is able to modify only his own nodes and not able to modify nodes
created by lecturer or other participants.
