\newpage

\chapter{Реализация}
\label{ch:chapter_2}

\section{Выбор технологий для реализации сетевой архитектуры}

\subsection{Детальная проработка требований}
\label{sec:detailed_requirements}
Существует множество способов установить сетевое взаимодействие между
приложениями, начиная от низкоуровневой обработки пакетов на уровне стека
TCP/IP, заканчивая использованием высокоуровневых объектно-ориентированных
библиотек для протоколов прикладного уровня. Был сформирован ряд ограничений
(см. главу \ref{sec:problem_statement}), которых необходимо придерживаться при
выборе технологии для построения сетевой архитектуры.

В соответствии с концепцией сетевого взаимодействия (см. главу
\ref{sec:collaborative_mindmapping}), мы имеем клиент-серверную архитектуру.
Взаимодействие пользователей будет более удобным, если сервер можно будет
создавать на любом устройстве и в любой момент времени. Взаимодействие должно
выглядеть следующим образом: пользователь создаёт сервер, другие участники
подсоединяются к нему и начинают редактирование. Каждое изменение, сделанное
участником, отправляется на сервер, который рассылает это изменение всем другим
участникам. Для надежного сообщения между клиентами и сервером, все участники
должны иметь одинаковую и верную копию карты.

Проект HiveMind поддерживает мобильные устройства и настольные компьютеры (см.
главу \ref{sec:project_summary}), имеющие различный способ подключения к
интернету. У каждого из этих способов есть свои преимущества и
недостатки. Пользователи настольных компьютеров, как правило, имеют широкий
канал интернет соединения, в отличие от пользователей мобильных устройств.
Мобильные устройства способны подключаться к интернету почти везде и в любое
время. В связи с нехваткой IPv4 адресов, операторы мобильной связи назначают
серые ip адреса мобильным устройствам, что делает данные устройства недоступными
напрямую из сети Интернет. Соединение по беспроводным сетям зачастую нестабильно
и иногда вызывает значительные задержки при передачи данных. Пользователи
настольных компьютеров могут использовать NAT или фаервол блокирующий
входящие соединения. В корпоративной среде, пользователи зачастую ограничены
HTTP прокси, как единственным способом доступа в сеть Интернет.

Подводя итог всем вышеперечисленным особенностям, был сформирован список
требований для выбираемой технологии промежуточного слоя.
\begin{itemize}
\item Взаимодействие основанное на клиент-серверной модели.
\item Сервер должен иметь поддержку подписки.
\item Пользователь может иметь медленное, ненадежное соединение до
сети Интернет, расположенное за NAT.
\item Не должно быть сложностей в создании сервера.
\item Выбранная технология должна поддерживаться библиотекой на языке
Python.
\end{itemize}

\subsection{Преимущества протокола XMPP}
XMPP (Extensible Messaging and Presence Protocol) "--- расширяемый протокол для
обмена сообщениями, в режиме близком к режиму реального времени. Протокол XMPP
может быть рассмотрен на нескольких уровнях абстракции. На нижнем уровне
абстракции, существует клиентское приложение, использующее протокол XMPP,
которое подключается к серверу и обменивается с ним сообщениями. Соединение с
сервером может быть установлено несколькими способами, даже поверх протокола
HTTP. На высоком уровне абстракции, клиент получает доступ ко всей XMPP сети,
где каждый её узел имеет уникальный идентификатор, называемый JID (Jabber
Identificator). Преимуществом является то, что пересылка сообщений между узлами
сети не требует дополнительных усилий. Клиент создаёт сообщение, адресованное
другому клиенту и посылает его на сервер, который отвечает за все операции,
связанные с доставкой данного сообщения.

Большое преимущество протокола XMPP "--- расширяемость. Он может быть расширен с
помощью расширяющих протоколов (XEP). XMPP является открытым протоколом и каждый
желающий может создать высокоуровневый протокол поверх него. Организация XMPP
Standards Foundation отвечает за процесс создания и поддержки данных протоколов.
Существует расширение XEP-0060 Publish-Subscribe \cite{xep-0060}. Оно отвечает
за то, как реализовывать сервис публикации/подписки поверх протокола XMPP. Любой
участник XMPP сети может создать сервис публикации/подписки.

XMPP был создан как протокол мгновенного обмена сообщениями, использующий XML
для формирования сообщений. XML создаёт избыточную информацию и его
использование может потребовать широкой полосы Интернет соединения. Но сообщения
между клиентом и сервером могут быть сжаты с использованием расширение XEP-0138
(Stream Compression extension). Таким образом, протокол XMPP может быть избавлен
от вышеназванного недостатка.

В настоящее время существует множество общедоступных XMPP серверов
поддерживающих общение в чате. Участие в подобных чатах доступно с мобильных
устройств и не требует широкополосного доступа в Интернет. С технической точки
зрения, совместное редактирование диаграмм очень похоже на участие в чате из
чего следует, что объём трафика не будет сильно отличаться. Исключением является
устройство, являющееся сервером. Данному устройству будет необходим более
широкий канал до сети Интернет для взаимодействия со многими клиентами.

XMPP protocol was created as an instant messaging protocol. It is convenient to
exchange human-readable messages in human-readable format. For the sake of
interoperability it uses XML-based structures for message formatting. Протокол
XMPP c расширением публикации/подписки удовлетворяет требованиям к технологии
промежуточного слоя (см. главу \ref{sec:detailed_requirements}). Он позволяет
избежать почти все сложности связанные с реализацией клиент-серверной
архитектуры и с точки зрения данных требований не имеет недостатков, поэтому он
был выбран технологией промежуточного слоя.

\subsection{Выбор библиотеки для работы с XMPP протоколом}
Следующей задачей является выбор библиотеки языки Python, поддерживающей
расширение XEP-0060. На сайте the XMPP Foundation \cite{xmpp} есть список из
восьми библиотек поддерживающих XMPP. Некоторые библиотеки более не
поддерживаются (jabber.py), некоторые требуют использования более новых (2.6,
3.x) версий языка Python, недоступных под платформой Maemo (pyxmpp), другие же
являются исследовательскими проектами и не предназаначены для повсеместного
использования (SleekXMPP). Twisted "--- единственный инструмент для работы с
XMPP протоколом, доступный в репозитории Maemo.

Twisted "--- событийно-ориентированный сетевой фрэймворк, поддерживающий
множество протоколов таких как: TCP, UDP, SSL/TLS, HTTP, XMPP, NNTP, IMAP, SSH,
IRC, FTP и множество других \cite{twisted}. Twisted не имеет встроенной
поддержки XEP-0060, но существует внешняя библиотека Wokkel \cite{wokkel},
поддерживающая данное расширение. Данная библиотека отсутствует в репозитории
Maemo. Для того, чтобы иметь возможность её использовать, было принято решение о
создании и поддержки пакета для платформы Maemo. Дополнительная работа была
сделана для того, чтобы обеспечить поддержку мобильных устройств.


\section{Protocol For Collaboration}

% really awful beginning
 The development of any complex protocol and it implementation is a
 labour-consuming process. Our development team had no previous experience in
 such field and thus we decided to use iterative approach. At the first iteration
 protocol for the team work should be as simple as possible. Thereby allow us to
 develop network architecture and to test selected libraries.

 % data structure
 Publish-Subscribe extension requires to share information in the form of nodes
 and items. Node-item system can be compared with file system, where nodes
 represent directories and items represent files. Each item may have unique
 identifier. Subscriber can retrieve items from service either by name or get a
 number of last published items. Items should contain a valid XML data.

 HiveMind has undo/redo capabilities as any good document editor does. Now they
 are implemented on top of QUndoStack. When user makes a change to the mind map
 QUndoCommand is created and pushed into the stack. This allows the user to
 travel through the history of modifications. We decided to use undo/redo stack
 to model data structures of the protocol. All mind map data can be placed
 inside a single node. First item must contain XML-serialized mind map. All other
 items hold small changesets, witch--- users make to shared map. These
 modifications are the XML-serialized versions of QUndoCommand.

 % notification propagation
 First item in the node is placed by the service in the moment of creation. Other
 items are published by participants of collaboration. Every new modification
 published in the node is retransmitted via update notifications to all
 subscribers and the service holder (see fig. \ref{users_collaboration_example}). 
 Service may reject the changeset if there are some defects (e.g. user wants to 
 update mind map node when it was already deleted by another user) and send error
 notification back to the subscriber.

 Protocol design proposes asynchronous propagation of modifications on the client
 side of publish/subscribe interaction. User changes to the mind map in the form
 of XML-serialized command are transmitted to the service and do not store in
 the local undo stack. Only changesets that were received as update notifications
 are added to the stack.

 Subscribers can retrieve all items stored in the node in any time. This
 way clients may synchronize contents of their local copy of mind map if
 transmitted changeset is rejected. Service does not need any additional effort
 to have up-to-date map because all notifications are local and can not be lost
 during transmission.

 To achieve this asynchronous process new element was added to the core of
 HiveMind --- NetworkController. It manages pub/sub protocol handlers. All
 QUndoCommands created as a result of mind map modifications are passed to the
 controller. If there is no network collaboration at the moment command will be
 sent back to MainWindowController and added to the local undo/redo stack.
 Otherwise command will be serialized and send to the service. Update
 notifications are deserialized into QUndoCommands and added to the undo/redo
 stack.

 The drawbacks of current collaboration protocol design and implementation
 include following statements. Client must wait for an update notification in
 order to see changes that he or she made to the shared mind map. Participants
 cannot use undo/redo commands.

 not 4 current document, may be next one
 There are brilliant examples on how to build iterative update shared space -
 Version Control Systems. Their main aim is almost the same as editing shared
 mind map: provide access to common space of source files. VCS can do all the 
 work here, but they do not provide any notification to all people involved in
 collaborative work. They use robust protocols, send only difference between
 committed versions, and do it really slow. \ldots

\section{Network Subsystem Architecture}

The XMPP protocol family is build out of two things: the core technology and the
XMPP Extension protocols (XEP). The core is responsible for the message exchange
between different parts of the system. Various extension protocols are built on
top of the core. The process of creation and maintenance of such protocols is
managed by XMPP Standards Foundation \cite{xmpp-standarts}.

The XMPP publish-subscribe extension \cite{xep-0060} uses the classic
``publish-subscribe'' or ``observer'' design pattern: a person or application
publishes information, and an event notification (with or without payload) is
broadcasted to all authorized subscribers. In general, the relationship between
the publisher and the subscriber is mediated by a service that receives
publication requests and broadcasts event notifications to subscribers.

Service may support several distinct entities available for subscription. These
entities are called ``nodes''. There are different notification lists for each
node hosted on the service. Publishers send data to the node and subscribers
receive event notifications from it. Nodes can also maintain history of events
and provide other services that supplement the pure pubsub model. Data send to
and from the node is called ``item''.

In terms of publish-subscribe extension the collaboration process can be
described as follows. A user creates a service and a single node for message
exchange. The other participants subscribe to the created node. When anyone
makes a change to the mind map it is sent to the service, which notifies all
participants about the change. The data is sent in the form of the item
payload. Having this principle scheme in mind, we began to form the teamwork
protocol and implement it in detail.

Each change to the mind map is atomic. All changes to the mind map are done with
the use of dialogs. When the edit operation is completed, QUndoCommand is
created and pushed into the command stack. For every change command type XML
serialization and deserialization functions are made.  The use of edit commands
causes the problem of sharing initial contents of the mind map. In order to
execute identical commands, all participants must have exact copies of the
initial mind map. In order to achieve this goal, the first item on the node must
contain XML-serialized mind map. All the other items, as discussed earlier, hold
serialized change commands.  When a participant subscribes to the node he/she
receives all the data stored in the node.

% notification propagation

Each modification published in the node is recorded as a ``changeset''. The
changeset holds information about type of change, time it was formed, and the
author of the change (see fig.~\ref{Changeset propagation}). Service may reject
the changeset if it is irrelevant (e.g. user tries to update mind map node when
it was already deleted by another user) and send error notification back to the
subscriber.

Protocol design proposes asynchronous propagation of modifications on the client
side of publish/subscribe interaction. Modifications to the mind map are
transmitted to the service in the form of XML-serialized commands and are not
stored in the local undo stack. The only changesets received via update
notifications are added to the stack. So, the subscriber must wait for the
correct notification from the service in order to see changes that he or she has
made to the mind map.

The subscribers can retrieve all items stored in the node anytime. This
capability is used to synchronize contents of their local copy of the mind map
if transmitted changeset is rejected. Service does not need any additional
effort to have up-to-date map because all notifications are local and cannot be
lost during transmission.

To implement this asynchronous process, we introduced a new element to HiveMind
core --- NetworkController. It manages publish-subscribe protocol handlers. All
QUndoCommands, created as a result of mind map modifications, are passed to the
controller. If there is no network collaboration at the moment, the command will
be added to the local undo/redo stack. Otherwise, command will be serialized and
sent to the service. Update notifications are deserialized into QUndoCommands
and added to the undo/redo stack.


\section{Implementation of Network Subsystem}

Network subsystem of HiveMind is implemented on top of Twisted \cite{twisted} and
Wokkel \cite{wokkel}. Twisted is a framework for writing asynchronous,
event-driven network applications in Python. It has additional support for many
GUI frameworks like Qt, GTK, Tk, and others.

Wokkel library is a pack of enhancements for Twisted. Particularly, Wokkel
provides a mechanism for easier implementation of XMPP Enhancement Protocols
(XEP). It supports for Service Discovery (XEP-0030), Publish-Subscribe
(XEP-0060) and other XEPs. Implementation of XEP-0060 does not contain business
logic. It means that Wokkel responds for receiving and generating XMPP requests
according to XEP-0060 specification. Wokkel reacts on external pub/sub events
and invokes corresponding methods.

XEP-0060 is very large and complicated. Implementation of all features,
necessary for HiveMind, would take lots of time. Idavoll library is built on top
of Wokkel and provides implementations of many XEP-0060 features such as
``Subscribing'', ``Publishing'', ``Persistent items'', ``Node creation'' and
etc.

Idavoll has many classes needed to implement XEP-0060 specification (see
fig.~\ref{Network classes}). Node class represents a XEP-0060 node. There are
two node types: Leaf and Collection. A leaf node contains a published item,
whereas a collection node contains other nodes.

HivemindNode class inherits LeafNode, but stores the published items in
ChangesetStack instead of a simple list. Using of ChangesetStack allows to check
integrity and correctness of data. Storage class responds for managing all nodes
on the service. BackendService is an implementation of XEP-0060 business logic.
PubSubServiceFromBackend inherits Wokkel's PubSubService class. It invokes
methods for handling corresponding XMPP requests and delegates action performing
to BackendService class.

Mobile devices often have unstable internet connection, so the user have to be
notified when XMPP session is lost. We check connection using XEP-0199 (XMPP
Ping) \cite{ping-xep-0199}. PingClientProtocol class sends ping to the XMPP
server and waits for reply. If there is a certain number of failed pings, the
connection is considered as lost.

The similar mechanism is used for checking participation status of a person. On
the service each participant has his/her own instance of PingClientProtocol. Ping
handler on the client side replies only to the service which it is connected
to. We implemented PingManager class to manage multiple instances of
PingClientProtocol (see fig.~\ref{Ping manager}).  It creates/deletes instances
and starts/stops ping to the certain entity. PingClientProtocol class is
responsible for notifying NetworkController about participant status, which is
shown to the service owner (see fig.~\ref{Permissions dialog}).

\section{Access Control System}
\label{Access control system}

By default, all participants of teamwork have equal permissions to contribute to
the mind map. It is quite convenient for brainstorming-like activities when the
purpose of the collaboration is to generate some materials or to find a solution
for a long-standing problem. This kind of behavior looks unsuitable for other
use cases. Sometimes it is useful to restrict access for particular users in
order to prevent accidental interference of teamwork. To take such scenarios
into account we introduced access control system to HiveMind.

XEP-0060 provides a feature, named Access Model, which can be associated with
authentication system. The user, who creates the mind map, can set trust level
for all new participants i.e. control who can participate in collaboration.
There are four access models implemented in HiveMind:
\begin{itemize}
\item ``Open'' --- any person may join collaboration;
\item ``Roster'' --- only contacts from the owner’s roster may join;
\item ``Authorize'' --- the owner choose who may join on the fly. When a new
  person is connected, the owner gets a participation request from the person;
\item ``Whitelist'' --- a person may join only if he/she is in the owner’s
  whitelist.
\end{itemize}

``Affiliations'' is the next feature, defined in XEP-0060, being a part of
HiveMind access control system. This feature provides authorization capabilities
to XEP-0060. After the person joined collaboration, he/she has a role, which
determines a set of allowed actions. There are four roles implemented in
HiveMind:
\begin{itemize}
\item ``Outcast'' --- person not allowed to join collaboration i.e. in terms of
  IM he/she is banned;
\item ``Member'' --- person allowed to receive items;
\item ``Publisher'' --- person allowed to publish and receive items;
\item ``Owner'' --- similar to the Publisher, but allowed to configure
  collaboration behaviour.
\end{itemize}
Service owner can edit role of desired person at any time with the use of
permissions dialog (fig.~\ref{Permissions dialog}).

XEP-0060 has features that makes access control even more flexible. In some
cases it might be useful to temporarily assign publisher role to all
participants. HiveMind has implementation of XEP-0060 feature named Publish
Model. It determines two cases of who is allowed to make changes to the
mindmap. In the first case it is a person whose affiliation is publisher, and in
the second case any participant is allowed to post changes.

Impelementation of access control system helps us to discover new use cases of
HiveMind. Presentation using HiveMind is one of such use cases. First of all,
lecturer can control who may join the presentation. Secondly, there are can be
more than one lecturer. Presentations using HiveMind distinguish from
collaborative editing: lecturer's current node and fold/unfold events must be
propagated through the network. This ensured that participants can track the
presentation movement.
 
Authorization system can be extended to greatly improve presentation
support. For example, lecturer may want to receive questions. Participants
can add nodes containing a questions or suggestions to lecturer mindmap.
Authorization system controls interaction between lecturer and participants e.g.
participant is able to modify only his own nodes and not able to modify nodes
created by lecturer or other participants.
