\chapter{Реализация расширений}

\section{Ruby on Rails}
Ruby on Rails "--- это фреймворк для построения веб-приложений в соответствии с
шаблоном проектирования Модель-Вид-Контроллер (MVC). Rails приложение состоит
из трёх ключевых уровней.

Уровень представления состоит из файлов-шаблонов, которые отвечают за
отображение данных приложения. Шаблоны могут быть различных видов, но основной
формат "--- это HTML со вставками на языке Ruby, за генерацию которого отвечает
движок ERB языка Ruby.

Уровень модели представляет доменную область и инкапсулирует бизнес логику
приложения. Очень часто классы модели в Rails приложении связаны с базой данных
(БД) через ActiveRecord. ActiveRecord даёт возможность работать со строками в
БД как с обычными объектами, а также дополнять эти объекты методами
бизнес-логики.

Контроллеры отвечают за обработку входящих HTTP запросов и формирование ответа.
Зачастую, ответ возвращается в HTML, но также возможна генерация ответа в XML,
JSON, PDF и других форматах. Контроллеры генерируют ответ на основе данных,
полученных из моделей, и соответствующих шаблонов представления.
% временное изображение, будет что-то похожее.
\inspicture{rails-architecture}{Архитектура Rails приложения}

\subsection{Структура Rails приложения}
Rails приложение состоит из нескольких директорий. Далее будут перечислено
назначение основных из них:
\begin{itemize}
\item app : директория, содержащая компоненты приложения. Она включает в
себе поддиректории, содержащие модели, шаблоны представления, контроллеры и
вспомогательные (Helper) классы для них;
\item app/controllers: классы контроллеров;
\item app/helpers: вспомогательные классы для шаблонов представления, моделей и
контроллеров;
\item app/models: классы модели;
\item app/view: шаблоны представления, предназначенные для генерации HTML;
\item app/view/layouts: макеты для шаблонов представления, которые позволяют
избежать дублирования кода, выделив общие части на шаблонах в макет;
\item config: содержит конфигурацию приложения, в том числе конфигурацию БД
и различных окружений;
\item db: директория используется для того, чтобы хранить данные связанные
с БД, к примеру схему БД и файлы миграции;
\item lib: библиотеки и файлы со вспомогательными классами;
\item public: статические данные: javascript, css, HTML файлы и изображения;
\item script: файлы скриптов для запуска различных инструментов;
\item test: различные виды классов, предназначенные для тестирования
приложения;
\item vendor: сторонние библиотеки.
\end{itemize}
В папке vendor/plugins содержатся плагины Redmine. Структура директории с
плагином во многом схожа с Rails, поскольку плагин является миниатюрным Rails
приложением. Директория плагина содержит папки, назначение которых
было описано выше: app, db, config, test, lib. А также папка assets, содержание
которой соответствует папке public в Rails


\section{Ограничение доступа к отдельным вики-страницам}

\subsection{Регистрация плагина}
Для того чтобы Redmine успешно зарегистрировал плагин, необходимо создать
директорию со следующим именем `redmine\_<имя\_плагина>` в папке
vendor/plugins/. И разместить в созданной директории файл с именем init.rb, в
котором будет содержаться информация, необходимая для регистрации плагина. Файл
init.rb должен выглядеть следующим образом:
\lstset{language=Ruby}
\begin{lstlisting}
Redmine::Plugin.register :redmine_private_wiki do
  name 'Private Wiki'
  author 'Oleg Kandaurov'
  description 'Adds private pages to wiki'
  version '0.0.1'
end
\end{lstlisting}
Далее приводится описание каждого из операторов:
\begin{itemize}
  \item Redmine::Plugin.register :redmine\_private\_wiki: начало блока,
  который производит регистрацию плагина под именем redmine\_private\_wiki;
  \item name: имя плагина, отображаемое пользователю;
  \item author: имя автора плагина;
  \item description: краткое описание плагина;
  \item version: версия плагина.
\end{itemize}

\subsection{Поиск контроллера и шаблона представления}
В первую очередь необходимо найти контроллер и шаблон представления, отвечающий
за генерацию вики-страниц. Запустив приложение, увидим, что вики-страница под
именем `page 1`, в проекте под именем `my\_project` имеет следующий адрес:
/projects/my\_project/wiki/page\_1. Теперь определим, какой контроллер
отвечает за обработку запроса на отображение вики-страницы. Для этого
в консоли, в папке проекта, вызовем команду rake routes, которая выведет список
всех маршрутов(в выводе опущена несущественная часть):
\small{
\begin{lstlisting}
...
GET    /projects/:project_id/wiki       {:action=>"show", :controller=>"wiki"}
GET    /projects/:project_id/wiki/index {:action=>"index", :controller=>"wiki"}
GET    /projects/:project_id/wiki/:id   {:action=>"show", :controller=>"wiki"}
PUT    /projects/:project_id/wiki/:id   {:action=>"update", :controller=>"wiki"} 
DELETE /projects/:project_id/wiki/:id   {:action=>"destroy", :controller=>"wiki"} 
...
\end{lstlisting}
}
Первый столбец указывает на тип HTTP запроса, а второй столбец на формат
адресной строки. На основе этих двух параметров диспетчер запросов выбирает
контроллер и метод, указанный в третьем столбце, в который он перенаправит
запрос. Легко заметить, что за генерацию искомой страницы отвечает метод show в
контроллере под именем wiki. Rails активно использует конвенции по
именованию. Из этих конвенций следует, что класс контроллера должен называться
WikiController и распологаться в директории /app/controllers.

Для того, чтобы найти шаблон представления, необходимо посмотреть на метод show
в классе WikiController(несущественная часть опущена).
\small{
\begin{lstlisting}
def show
  ...
  render :action => 'show'
end
\end{lstlisting}
}
render :action => 'show' указывает на то, что генерируемый шаблон представления
называется show. В соответствии с конвенциями именования, его следует искать в
директории /app/views/<имя\_контроллера> в файле show.html.erb.

\subsection{Redmine Hooks}
Redmine поддерживает концепцию Hook'ов. Hook "--- это API, который позволяет
расширить функциональность Redmine. При помощи Hook'a автор плагина может
зарегистрировать функции обратного вызова, которые вызовутся одна за другой,
когда исполнится определённый код в Redmine. В документации Redmine есть список
Hook'ов, но он не полный и авторы Redmine советуют самостоятельно просмотреть
интересующую часть кода на предмет наличия в ней Hook'ов.

При вызове Hook'a он исполняет зарегистрированные функции обратного вызова. Эти
функции содержат только один параметр "--- хэш, содержащий информацию
о контексте вызова. Вышеназванный хэш предоставляет данные, необходимые для
выполнения операций в функциях обратного вызова.

Redmine предоставляет три вида Hook'ов: для шаблонов представления, модели и
контроллеров. Разработчики Redmine советует использовать вместо двух последних
видов Hook'ов механизмы фреймворка Ruby On Rails и языка Ruby, которые будут
рассмотрены позже. Разберём работу Hook'ов для шаблонов представления.

Контекст, передаваемый в Hook для представления содержит следующие данные:
\begin{itemize}
  \item controller: ссылка на контроллер который производит генерацию
  текущего шаблона представления;
  \item project: текущий проект, если таковой установлен контроллером;
  \item request: объект, содержащий информацию о веб-запросе;
  \item дополнительные параметры, специфичные для Hook'a, которые могут
  быть найдены в вызове метода call\_hook на шаблоне представления.
\end{itemize}
Hook'и шаблонов представления исполняются при генерации шаблона. То есть этот
механизм позволяет автору встраивать HTML-код в места, определённые
расположением соответствующего Hook'а. Значение возвращаемое функцией обратного
вызова преобразуется в строку и встраивается в представление.

\subsection{Создание Hook'а для представления}
Шаблон представления для вики-страницы располагается в файле
/app/views/wiki/show.html.erb. Hook'и являются вызовом метода call\_hook,
которые в данном шаблоне отсутствуют. Это значит то, что Hook'и специфичные для
данного представления отсутствуют и нужно искать глобальные, присутствующие на
всех страницах. Все шаблоны в Redmine генерируются внутри главного макета,
находящегося в файле /app/views/layouts/base.html.erb. В данном макете,
определены несколько Hook'ов:
\begin{itemize}
  \item view\_layouts\_base\_html\_head: определён внутри секции head HTML
  документа и предназначен для подключения javascript библиотек и css стилей;
  \item view\_layouts\_base\_sidebar: добавляет элементы в
  боковую панель;
  \item view\_layouts\_base\_content: добавляет элементы в главную область
  страницы;
  \item view\_layouts\_base\_body\_bottom: добавляет элементы в конец секции
  body.
\end{itemize}
Из перечисленных Hook'ов, для наших целей в большей степени подходят
view\_layouts\_base\_html\_head и view\_layouts\_base\_body\_bottom.
Перейдём к процессу создания функции обратного вызова для вышеперечисленных
Hook'ов. Создадим файл lib/private\_wiki/hooks.rb внутри директории плагина и
укажем, чтобы Redmine загружал его при регистрации плагина поместив require
'private\_wiki/hook' в начало файла init.rb. В самом файле hooks.rb напишем
следующее:
\small{
\begin{lstlisting}
module PrivateWiki
  class PrivateWikiHook < Redmine::Hook::ViewListener
    render_on :view_layouts_base_html_head, :partial => 'hooks/html_header'
    render_on :view_layouts_base_body_bottom, :partial => 'hooks/body_bottom'
  end
end
\end{lstlisting}
}
\begin{itemize}
  \item module PrivateWiki задаёт область видимости создаваемого класса;
  \item Redmine::Hook::ViewListener класс, от которого должен быть унаследован
  класс, регистрирующий Hook'и;
  \item render\_on :view\_layouts\_base\_html\_head, :partial => 'hooks/html\_header'
 регистрирует функцию обратного вызова, которая генерирует частичный шаблон представления с
именем hooks/html\_header при вызове Hook'а view\_layouts\_base\_html\_head.
\end{itemize}
В соответствии с конвенциями именования, частичные шаблоны представления,
упомянутые выше, должны располагаться в директории app/views/hooks в файлах
\_html\_header.html.erb \_body\_bottom.html.erb. В файле
\_html\_header.html.erb реализуем подключение css-стилей следующим образом:
\small{
\begin{lstlisting}
<% if controller and 
  controller.class.name == 'WikiController' and 
  controller.action_name == "show" %>
    <%= stylesheet_link_tag "private_wiki.css", 
      :plugin => "redmine_private_wiki", 
      :media => "screen" %>
<% end %>
\end{lstlisting}
}
В первых трёх строках указано, что будем осуществлять подключение стиля только
если процесс генерации страницы был инициирован контроллером WikiController и
методом show. Подключение файлы с css стилями осуществляется с помощью Helper'а
stylesheet\_link\_tag. Механизм Helper'ов позволяет выделить повторяющийся код
в методы и получить преимущества от многократного использования кода. В Helper
передаются несколько параметров указывающих, где располагается файл стиля. В
данном случае файл c css стилями должен быть расположен в директории
assets/stylesheets/private\_wiki.css. На данном этапе можно запустить Redmine и
убедиться, что файл стилей подключается только на вики-страницах.


\section{Улучшенный механизм позиционирования всплывающего календаря}

\section{Возможность указать тип задачи при составлений обзора кода}

\section{Улучшенная система навигации между страницами просмотра изменений}
% Патч такой-то исходный код в приложении
% ~\ref{appendix:back-link-to-rev-from-diff.patch})

\section{Расширение интеграции с системами контроля версий}

\section{Рассылка уведомлений о приближающихся и просроченных задачах}

\section{Ограничение доступа к репозиториям}

\section{Изображения-ссылки в боковой панели}



%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "diploma"
%%% End: 
