\lstset{language=Ruby}

\chapter{Реализация расширений}
\label{section:implementation}

\section{Ограничение доступа к отдельным вики-страницам}
\label{section:private_wiki}
В данном пункте детально описана реализация плагина, предоставляющего
функционал в соответствии с требованиями, определёнными в пункте
\ref{definition:private_wiki}. Реализация плагина была разбита на несколько
этапов:
\begin{itemize}
  \item регистрация плагина в системе;
  \item изменение базы данных;
  \item добавление прав доступа;
  \item изменение классов бизнес-логики;
  \item связывание представления с бизнес-логикой;
  \item изменение представления.
\end{itemize}
В последующих пунктах описаны детали реализации каждого из этапов.

\subsection{Регистрация плагина}
Создание плагина начинается с регистрации в системе. Для этого необходимо
определить место, для размещение плагина, структуру директорий
внутри папки с плагином и непосредственно произвести регистрацию.

В документации Redmine сказано, что плагины должны находится в директории
\textit{vendor/plugins}. Плагины Redmine являются миниатюрными Rails
приложениями, в следствии чего структура и назначение директорий в плагине
совпадает с соответствующими директориями в Rails.
\begin{itemize}
\item \textit{app/controllers} классы контроллеров;
\item \textit{app/helpers} вспомогательные (Helper) классы для шаблонов
представления, моделей и контроллеров;
\item \textit{app/models} классы модели;
\item \textit{app/view} шаблоны представления;
\item \textit{app/view/layouts} макеты для шаблонов представления;
\item \textit{config} конфигурация приложения, в том числе конфигурация БД и
различных окружений;
\item \textit{db} данные связанные с БД, к примеру схема БД и файлы миграции;
\item \textit{lib} библиотеки и различные файлы с классами;
\item \textit{public} статические данные: javascript, css, HTML файлы и
изображения;
\item \textit{vendor} сторонние библиотеки.
\end{itemize}
Для того, чтобы зарегистрировать плагин необходимо создать файл
\textit{init.rb} в директории \textit{/vendor/plugins/<имя\_плагина>}.

Плагин был назван \textit{private\_wiki} и соответственно была создан файл
\textit{init.rb} следующего содержания:
\small{\begin{lstlisting}
Redmine::Plugin.register :redmine_private_wiki do
  name 'Private Wiki'
  author 'Oleg Kandaurov'
  description 'Adds private pages to wiki'
  version '0.0.1'
end
\end{lstlisting}}
\textit{Redmine::Plugin.register} "--- функция, которая производит регистрацию
плагина под именем \textit{redmine\_private\_wiki}. На остальных строках
указана информация о плагине:
\begin{itemize} 
  \item \textit{name} имя плагина, отображаемое пользователю;
  \item \textit{author} имя автора плагина;
  \item \textit{description} краткое описание плагина;
  \item \textit{version} версия плагина.
\end{itemize}

Плагин был зарегистрирован в системе и информация о нём, отображается в панели
администратора в соответствующей закладке, отображённой на рисунке
\ref{picture:plugin-registered}
\inspicture{plugin-registered}{Панель администрирования, вкладка
<<Плагины>>}{1}

\subsection{Миграция базы данных} 
\label{section:migration}
В БД должна храниться информация о том является страница закрытой или нет.
Следовательно необходимо определить место для хранения данной информации и
соответствующим образом изменить БД добавив поле, характеризующее закрытость
страницы. 

Механизм миграции "--- это часть Rails модуля ActiveRecord, при помощи которого
разработчикам предоставляется удобный способ изменения БД. Главное преимущество
механизма миграции в том, что он не зависит от БД, поскольку трансформации
записываются в специальном формате. Файл миграции может быть применён к БД с
помощью запуска команды \textit{rake db:migrate}. Благодаря механизму миграции,
возможно использование различных БД для разных сред без изменения файлов
миграции. К примеру, SQLite3 для разработки и MySQL для тестовой среды.

В процессе изучения БД было выявлено, что данные о вики-странице хранятся в
таблице \textit{wiki\_pages}. Было принято решение, добавить в вышеназванную
таблицу дополнительный столбец, определяющий закрытость страницы. Для изменения
БД был использован механизм миграции, поскольку разработчики Redmine
предусмотрели возможность использования механизма миграции в плагинах. Данные о
миграции были размещены в файле \textit{db/migrate/0001\_add\_private\_wiki.rb}
со следующим содержанием:
\small{\begin{lstlisting}
class AddPrivateWiki < ActiveRecord::Migration
  def self.up
    add_column(:wiki_pages, "private", :boolean, :default => false)
  end
  def self.down
    remove_column(:wiki_pages, "private")
  end
end
\end{lstlisting}}
Класс миграции унаследован от \textit{ActiveRecord::Migration} и  в нём
определены два метода: \textit{up} и \textit{down}.
Первый метод описывает действия при применении миграции, а второй при её
отмене. При применении миграции осуществляется добавление столбца
\textit{private}, имеющего \textit{boolean} тип, в таблицу
\textit{wiki\_pages}. А при отмене миграции столбец \textit{private} будет
удалён из таблицы \textit{wiki\_pages}. Применение миграции осуществляется с
помощью вызова команды \textit{rake db:migrate\_plugins}.

Созданный файл миграции был применён и таким образом в таблицу, хранящую данные
о вики-страницах, добавлен столбец отражающий закрытость страницы. 

\subsection{Система контроля доступа}
\label{section:access_control}
Вики-страница была наделена дополнительной характеристикой, отражающей
закрытость страницы. На данном шаге необходимо создать право доступа, с помощью
которого будет осуществляться контроль отображения закрытых вики-страниц. 

Redmine предоставляет гибкую систему контроля доступа на основе ролей. Роль
включает в себя определённое количество прав доступа, которые сгруппированы в
соответствии с назначением, по модулям. Гибкость заключается в том, что
администраторы имеют возможность создавать дополнительные роли, а также
назначать пользователю разные роли в зависимости от проекта.

Системой плагинов Redmine предусмотрена возможность регистрации дополнительных
прав доступа. Следующие изменения были внесены в файл \textit{init.rb}:
\small{
\begin{lstlisting}
project_module :wiki do
  permission :view_private_wiki_pages, {}
end
\end{lstlisting}}
Метод \textit{project\_module} добавляет право доступа в модуль \textit{wiki}.
Во второй строке определяется новое право доступа с именем
\textit{view\_private\_wiki\_pages}.


В систему контроля доступа было добавлено новое право доступа под именем ``View
private wiki pages'', отображённое на рисунке
\ref{picture:settings-permissions}.
\inspicture{settings-permissions}{Панель администрирования, вкладка <<Роли и
права доступа>>}{1}


\subsection{Расширение классов во время выполнения}
\label{section:metaprogramming} 
Задача заключается в том, чтобы найти и изменить бизнес-логику, связанную с
проверкой доступа к закрытым вики-страницам. Проверка должна осуществляться
при помощи поля <<закрытости>> в вике-странице и права на её просмотр,
созданном в предыдущем пункте.

Право доступа, отвечающее за видимость вики-страниц называется
\textit{view\_wiki\_pages}. Поиск по исхдным кодам Redmine показал, что поле
используется в классе \textit{WikiPage} в методе \textit{visible?}:
\small{\begin{lstlisting}
def visible?(user=User.current)
  !user.nil? && user.allowed_to?(:view_wiki_pages, project)
end
\end{lstlisting}}
Метод \textit{allowed\_to?} класса \textit{User} проверяет наличие у
пользователя права на просмотр вики-страниц в заданном проекте. Следовательно
необходимо изменить поведение метода \textit{visible?} в классе
\textit{WikiPage}.

\subsubsection{Расширение классов во время выполнения}
Приложения на Ruby способны программно изменять свою структуру во время
выполнения и один из способов изменить поведение класса "--- расширить его с
помощью модуля, путём вызова метода \textit{include} на классе, в параметрах
которого содержится модуль для расширения. Разработчики Redmine советуют
выполнять расширение модулем в функции обратного вызова \textit{to\_prepare} в
классе \textit{Dispatcher}. Функция \textit{to\_prepare} вызывается единожды
при запуске приложение или при каждом запросе, в зависимости от того, в каком
режиме запущено приложение. Код, осуществляющий расширение, был помещён в файл
\textit{init.rb}:
\small{\begin{lstlisting}
require 'private_wiki/wiki_patch' require 'dispatcher' Dispatcher.to_prepare
:redmine_private_wiki do
  unless WikiPage.included_modules.include? PrivateWiki::WikiPatch
    WikiPage.send(:include, PrivateWiki::WikiPatch)
  end
end
\end{lstlisting}}
В первых двух строках производится подключение файлов с модулем для расширения
и с классом \textit{Dispatcher} cоответственно. \textit{Dispatcher.to\_prepare}
регистрирует функцию обратного вызова. На следующей строке идёт проверка,
недопускающая повторное включение модуля. И на пятой строке производится
включение модуля \textit{PrivateWiki::WikiPatch} в класс \textit{WikiPage}.

Модуль был размещён в файле \textit{private\_wiki/wiki\_patch}:
\small{\begin{lstlisting}
module PrivateWiki
  module WikiPatch
    def self.included(base)
      base.send(:include, InstanceMethods)
      base.class_eval do
      end
    end
    module InstanceMethods
    end
  end
end
\end{lstlisting}}
Метод \textit{included} вызывается при включении модуля в класс, в параметр
\textit{base} которого будет помещён расширяемый класс. Вызов метода
\textit{base.send(:include, InstanceMethods)} расширяет класс модулем, методы
которого будут доступны экземплярам расширяемого класса, а методы размещенные
внутри блока \textit{base.class\_eval} будут доступны из класса.

\subsubsection{Перехват вызовов метода}
Модуль ActiveSupport содержит метод \textit{alias\_method\_chain}, позволяющий
перехватывать обращение к заданному методу. Он был использован для изменения
работы метода \textit{visible?}:
\small{\begin{lstlisting}
base.class_eval do
  alias_method_chain :visible?, :private_wiki
end
\end{lstlisting}}
При вызове \textit{alias\_method\_chain} создаётся метод
\textit{visible\_without\_private\_wiki} в классе \textit{WikiPage}. Данный
метод, осуществляет проброс вызова на оригинальный метод \textit{visible?}. А
обращение к методу \textit{visible?} перенаправляет вызывающего на метод
\textit{visible\_with\_private\_wiki}. То есть стало возможным, контролировать
вызов метода \textit{visible?}.

Вызов метода \textit{visible?} будет перенаправлен на метод
\textit{visible\_with\_private\_wiki}, который следует определить
самостоятельно:
\small{\begin{lstlisting}
module InstanceMethods
  def visible_with_private_wiki?(user)
    if self.private and !is_private_page_visible?(project, user)
      return false
    end
    visible_without_private_wiki?(user)
  end
end
\end{lstlisting}}
If-условие производит проверку, если страница является закрытой и пользователь
не имеет прав на просмотр скрытых страниц, то метод возвращает \textit{false},
в противном случае вызывается оригинальный метод \textit{visible?}. 

С помощью средств метапрограммирования была создан механизм, позволяющий
вносить изменения в классы бизнес-логики. Созданного механизма был использован
для изменения метода, отвечающий за проверку видимости вики-страниц.


\subsection{Маршрутизация запросов}
\label{section:routing}
На вики-странице должен располагаться элемент, отвечающий за скрытие/открытие
вики-страницы. Элемент должен посылать запрос, который будет изменять состояние
страницы. Задача состоит в следующем: найти шаблон-представление, отвечающий за
генерацию вики-страницы, и специальным образом сопоставить запрос на
скрытие/открытие вики-страницы с методом в контроллере, который будет
ответственным за его обработку.

Запрос, поступающий в Rails приложение проходит несколько стадий обработки,
отображенных на рисунке \ref{picture:rails-request-processing}.
В начале запрос попадает в сервер приложений, который незамедлительно
возвращает ответ, если запрашивается статический файл, а в противном случае
перенаправляет запрос в \textit{Dispatcher}. \textit{Dispatcher} производит
разбор входящего запроса и на основе таблицы маршрутизации перенаправляет его в
соответствующий контроллер. Контроллер генерирует ответ на основе шаблонов
вида. После окончания работы контроллера, \textit{Dispatcher} отправляет ответ
инициатору запроса.
\inspicture{rails-request-processing}{Обработка запроса Rails приложением}{0.6}

В первую очередь необходимо определить определить контроллер обрабатывающий
запрос на отображение вики-страницы. Вики-страница под именем \textit{page1}, в
проекте под именем \textit{my\_project} имеет следующий адрес
\textit{projects/my\_project/wiki/page1}. Контроллер, обрабатывающий данный
запрос, может быть определён на основе таблицы маршрутизации запросов,
вызываемой по команде \textit{rake routes} (в выводе опущена несущественная
часть):
\small{\begin{lstlisting}
GET    /projects/:project_id/wiki       {:action=>"show", :controller=>"wiki"}
GET    /projects/:project_id/wiki/index {:action=>"index", :controller=>"wiki"}
GET    /projects/:project_id/wiki/:id   {:action=>"show", :controller=>"wiki"}
PUT    /projects/:project_id/wiki/:id   {:action=>"update",
:controller=>"wiki"} DELETE /projects/:project_id/wiki/:id  
{:action=>"destroy", :controller=>"wiki"}
\end{lstlisting}}
Первый столбец указывает на тип HTTP запроса, а второй определяет формат
адресной строки. На основе данных параметров \textit{Dispatcher} выбирает метод
контроллера, указанный в третьем столбце, в который будет перенаправлен запрос.
Легко заметить, что в данном случае, за генерацию запроса отвечает метод
\textit{show} в контроллере под именем \textit{wiki}. Rails активно использует
конвенции по именованию. Из этих конвенций следует, что класс контроллера
должен называться \textit{WikiController} и располагаться в директории
\textit{/app/controllers}.

\subsubsection{Добавление маршрута}
Для того, чтобы связать запрос, посылаемый из представления, с методом
контроллера необходимо добавить маршрут в файл \textit{config/routes.rb}:
\small{\begin{lstlisting}
ActionController::Routing::Routes.draw do |map|
  map.resources :projects do |project|
    project.private_wiki_change_privacy
        'wiki/:id/change_privacy/:private',
        :controller => 'wiki', :action => 'change_privacy',  :conditions =>
            {:method => :post}
  end
end
\end{lstlisting}}
В первой и второй происходит подготовка к регистрации маршрута. В третьей
строке создаётся маршрут под названием \textit{private\_wiki\_change\_privacy}.
И в следующих строках указывается, что запрос, адрес назначения которого
соответствует шаблону \textit{wiki/:id/change\_privacy/:private}, следует
перенаправить в контроллер c именем \textit{wiki} в метод
\textit{change\_privacy}. Следует заметить, что \textit{private} и \textit{id}
являются параметрами, которые доступны в поле \textit{params} в контроллере.

В данном пункте был добавлен маршрут, который направляет запрос, шаблон
которого соответствует строке \textit{wiki/:id/change\_privacy/:private}, в
метод \textit{change\_privacy} класса \textit{WikiController}.


\subsection{Redmine Hooks}
\label{section:redmine_hooks}
На вики-страницу должны быть добавлены два элемента: элемент, указывающий на
то, что страница закрыта и элемент позволяющий изменять закрытость страницы.
Хорошим стилем организации HTML страницы, является отделение структуры
документа от его оформления, поэтому оформление добавляемых элементов должно
располагаться в файле с CSS стилем.

Redmine поддерживает концепцию Hook'ов (описание в приложении \ref{glossary}).
В документации Redmine есть список Hook'ов, но он не полный и авторы Redmine
советуют разработчикам самостоятельно просмотреть интересующую часть кода на
предмет наличия в ней Hook'ов. При достижении Hook'a Redmine исполняет
зарегистрированные функции обратного вызова, в который передаётся контекст
вызова. Redmine предоставляет три вида Hook'ов: для шаблонов представления,
модели и контроллеров. Разработчики Redmine советуют использовать вместо двух
последних видов Hook'ов механизмы фреймворка Ruby On Rails и языка Ruby,
рассмотренные в параграфе \ref{section:metaprogramming}. Контекст, передаваемый
в Hook шаблона представления содержит следующие данные:
\begin{itemize}
  \item \textit{controller} ссылка на контроллер который производит генерацию
  текущего шаблона представления;
  \item \textit{project} текущий проект, если таковой установлен контроллером;
  \item \textit{request} объект, содержащий информацию о веб-запросе;
  \item дополнительные параметры, специфичные для Hook'a, которые могут
  быть найдены в вызове метода \textit{call\_hook} на шаблоне представления.
\end{itemize}
Значение, возвращаемое зарегистрированной функцией обратного вызова,
преобразуется в строку и встраивается в представление. Таким образом механизм
Hook'ов позволяет встраивать HTML-код в места, определённые расположением
соответствующего Hook'а.

\subsubsection{Создание Hook'а для подключения CSS стиля}
Необходимо определить местонахождение шаблона представления, за генерацию
которого отвечает метод \textit{show} класса \textit{WikiController}
(несущественная часть опущена).
\small{\begin{lstlisting}
def show
  render :action => 'show'
end
\end{lstlisting}}
\textit{render :action => 'show'} указывает на то, что генерируемый шаблон
представления называется \textit{show}. В соответствии с конвенциями
именования, его следует искать в директории
\textit{/app/views/wiki\_controller} в файле \textit{show.html.erb}.
Вызовы метода \textit{call\_hook} в шаблоне отсутствуют и следовательно
отсутствуют Hook'и, специфичные для данного представления. Все шаблоны
представления в Redmine генерируются внутри главного макета, находящегося в
файле \textit{/app/views/layouts/base.html.erb}. В данном макете, определены
несколько Hook'ов, в следующих местах страницы:
\begin{itemize}
  \item \textit{view\_layouts\_base\_html\_head} внутри HTML секции head ;
  \item \textit{view\_layouts\_base\_sidebar} в боковой панели;
  \item \textit{view\_layouts\_base\_content} в главной области страницы; 
  \item \textit{view\_layouts\_base\_body\_bottom} в конце HTML секции body.
\end{itemize}
Из перечисленных Hook'ов, для подключения CSS стиля подходит
\textit{view\_layouts\_base\_html\_head}. В файле
\textit{lib/private\_wiki/hooks.rb} был зарегистрирован Hook и создана функция
обратного вызова.
\small{\begin{lstlisting}
class PrivateWikiHook < Redmine::Hook::ViewListener
  render_on :view_layouts_base_html_head, :partial => 'hooks/html_header'
end
\end{lstlisting}}
\textit{Redmine::Hook::ViewListener} "--- класс, от которого должен быть
унаследован Hook представления. Метод \textit{render\_on} регистрирует функцию
обратного вызова, которая генерирует частичный шаблон представления с именем
\textit{hooks/html\_header} при вызове Hook'а
\textit{view\_layouts\_base\_html\_head}.

В соответствии с конвенциями именования, частичный шаблон представления,
упомянутый выше, должен располагаться в файле
\textit{app/views/hooks/\_html\_header.html.erb}:
\small{\begin{lstlisting}
<% if controller and
  controller.class.name == 'WikiController' and
  controller.action_name == "show" %>
    <%= stylesheet_link_tag "private_wiki.css",
      :plugin => "redmine_private_wiki",
      :media => "screen" %>
<% end %>
\end{lstlisting}}
В первых трёх строках указано, что подключение стиля следует выполнять только
если процесс генерации страницы был инициирован контроллером
\textit{WikiController} и методом \textit{show}. Подключение файла с CSS стилем
осуществляется с помощью вспомогательного метода
\textit{stylesheet\_link\_tag}. В вспомогательный метод передаются несколько
параметров, указывающих расположение файла стиля. В данном случае файл c CSS
стилем располагается в директории
\textit{assets/stylesheets/private\_wiki.css}.

\subsubsection{Размещение элементов на странице}
Для добавление элементов использован подход, описанный в предыдущем пункте. Был
зарегистрирован Hook \textit{view\_layouts\_base\_body\_bottom}, добавляющий
элементы в конец HTML секции \textit{body}. Был создан шаблон частичного
представления и добавлен соответсвующий код:
\small{\begin{lstlisting}
<% if @page.private? %>
  <span class="private">Private</span>
<% end %>
\end{lstlisting}}
На первой строке if-условие определяет, является ли страница закрытой и в
случае успеха размещяется элемент \textit{span}, служащий индикатором
закрытости. Элемент \textit{span} был размещён в конце страницы и необходимо
переместить данный элемент в наиболее заметное место, таким образом, чтобы не
нарушался общий стиль интерфейса. Подобное действие возможно произвести с
помощью исполнения javascript кода, модифицирующего дерево DOM:
\small{\begin{lstlisting}
$$('.contextual')[0].insert({top:$$('span.private')[0]})
\end{lstlisting}}
В Redmine используется javascript фреймворк Prototype, добавляющий
дополнительные функции для работы с деревом DOM. Функции
\textit{\$\$('.contextual')[0]} и \textit{\$\$('span.private')[0]} производят
поиск элементов по селекторам и возвращают первый из найденных элементов.
Селектор \textit{span.private} выбирает элемент, являющийся индикатором
закрытости, а селектор \textit{contextual} выбирает панель, в которой
расположены элементы управления вики-страницей. Функция \textit{insert}
помещает индикатор закрытости в панель управления вики-страницей.

Было произведено добавление элемента, с помощью которого, пользователь будет
изменять закрытость страницы.
\small{\begin{lstlisting}
<%= link_to_if_authorized(l(:button_hide_wiki),
  {:action => 'change_privacy', :id => @page.title, :private => 1}, :method =>
  :post, :class => 'icon icon-hide') if !@page.private? %>
\end{lstlisting}}
Вспомогательный метод \textit{link\_to\_if\_authorized} создаёт ссылку,
посылающую POST запрос, адресованный методу \textit{change\_privacy} в
контроллере \textit{wiki}, с параметром \textit{private} равным 1. Создание
данной ссылки происходит только в том случае, если страница открыта и у
текущего пользователя есть соответствующие права доступа. Созданная ссылка была
размещена в панеле управления вики-страницей с помощью техники, описанной в
предыдущем абзаце.Аналогичным образом была создана и размещена ссылка,
изменяющая статус вики-страницы на открытый.

В интерфейс вики-страниц были внесены следующие изменения:
\begin{itemize}
  \item добавлен индикатор закрытости;
  \item добавлен элемент, изменяющий закрытость страницы;
  \item подключен CSS стиль;
  \item произведено оформление вышеназванных элементов;
\end{itemize}
Результат работы показан на рисунке \ref{picture:private-wiki}, где слово
``Private'' в левой верхней части является индикатором, а c помощью элемента в
правой верхней части, под именем ``Reveal'', изменяется закрытость страницы.
\inspicture{private-wiki}{Закрытая вики-страница}{1}


\subsection{Запрет на отображение вики-страницы}
За отображение страницы отвечает контроллер. Контроллер должен отображать
вики-страницу и позволять изменять её статус, только пользователям с
соответствующими правами. В случае если пользователя нет прав, то должна
отображаться страница, сообщающая о запрете действия.

Для того, чтобы скрытая вики-страница не отображалась пользователям без
соответствующих прав, был произведён перехват метода \textit{show} в
контроллере \textit{WikiController}, с помощью техник, описанных в параграфе
\ref{section:metaprogramming}:
\small{\begin{lstlisting}
def show_with_private_wiki
  if not @page.visible? {return render_403}
  show_without_private_wiki
end
\end{lstlisting}}
На второй строке указано, что если просматриваемая страница скрыта от
пользователя, то следует вывести сообщение о том, что доступ к странице закрыт.
В противном случае выполнится оригинальный метод \textit{show}.

Следующий шаг заключается в создании метода \textit{change\_privacy}, который
будет отвечать за смену статуса вики-страницы:
\small{\begin{lstlisting}
def change_privacy
  find_existing_page 
  @page.update_attribute :private, params[:private]
  redirect_to :action => 'show', :project_id => @project, :id => @page.title
end
\end{lstlisting}}
Во второй строке вызывается метод, который присваивает переменной
\textit{@page} объект, связанный с текущей вики-страницей в БД. На третьей
строке вики-странице устанавливается атрибут \textit{private}, полученный из
запроса. На последней строке представление перезагружается.

Только пользователи с определёнными правами должны иметь право изменять
закрытость страницы. В связи с этим было добавлено дополнительное право
доступа:
\small{\begin{lstlisting}
permission :manage_private_wiki_pages, {:wiki => :change_privacy}
\end{lstlisting}}
\textit{:wiki => :change\_privacy} указывает на то, что только пользователи с
данным правом доступа имеют разрешение вызывать метод \textit{change\_privacy}
в контроллере \textit{wiki}.

Класс \textit{WikiController} был изменён таким образом, что в случае закрытой
вики-страницы:
\begin{itemize}
  \item только пользователи с правом доступа
  \textit{view\_private\_wiki\_pages} имеёт разрешение на просмотр;
  \item только пользователи с правом доступа
  \textit{manage\_private\_wiki\_pages} имеёт разрешение на смену статуса
  закрытости;
  \item выводится сообщение если у пользователя недостаточно прав.
\end{itemize}

\subsection{Результат}
Была подробно описана разработка плагина Private Wiki, а также рассмотрены
механизмы, задействованные при разработке плагина. Созданный плагин обладает
следующей функциональностью:
\begin{itemize}
  \item право доступа на просмотр закрытых вики-страниц;
  \item право доступа на изменение закрытости вики-страниц; 
  \item элемент управления в пользовательском интерфейсе, изменяющий
  видимость вики-страницы;
  \item индикатор, указывающий, что вики-страница является закрытой;
  \item оформление элементов в соответствии с интерфейсом Redmine.
\end{itemize}


\section{Ограничение доступа к репозиториям}
Требования к плагину указаны в пункте \ref{definiton:private_repository}.
Разработка плагина была разбита на две части: изменение представления и
внесение изменений в проверку прав доступа.

\subsubsection{Внесение изменений в интерфейс}
Необходимо добавить в панель со свойствами репозитория элемент интерфейса,
с помощью которого пользователь будет изменять закрытость репозитория, и
соответсвенно внести изменения в БД.

При помощи механизма миграции, описанного в п.\ref{section:migration}, в
таблицу, хранящую иноформацию о репозитории, был добавлен флаг
\textit{is\_private}, хранящий статус открытости репозитория. Далее был изменён
вспомогательный метод \textit{repository\_field\_tags}, с помощью которого
производится генерация формы со свойствами репозитория:
\small{\begin{lstlisting}
def repository_field_tags_with_private_repository(form, repository)
repository_field_tags_without_private_repository(form, repository) +
  content_tag('p', form.check_box(
      :is_private,
      :label => l(:field_is_private)
  ))
\end{lstlisting}}
Метод \textit{content\_tag} создаёт тег \textit{<p>} внутри которого будет
сгенеририрован поле-флаг привязанный к свойству \textit{is\_private} формы.
За сохранение и отображения \textit{is\_private} свойства отвечает механизм
работы с формами Rails приложения.

На форму со свойствами репозитория, был добавлен флаг под именем ``Private'',
отвечающий за его закрытость, который отображён на рисунке
\ref{picture:private-repository}
\inspicture{private-repository}{Вкладка со свойствами репозитория}{0.7}

\subsubsection{Внесение изменений в проверку прав доступа}
В Redmine предусмотрено два вида прав доступа к репозиторию:
\textit{browse\_repository} и \textit{view\_changesets}.
\textit{browse\_repository} позволяет видеть файлы в репозитории, a
\textit{view\_changesets} изменения в репозитории, то есть коммиты. 
Необходимо добавить право доступа к закрытым репозиториям и изменить проверку
на вышеназванные права с учётом закрытости репозитория.

Право доступа к закрытым репозиториям было создано, как описано в п.
\ref{section:access_control} и было названо
\textit{view\_private\_repositories}.
Проверка прав доступа к репозиториям была изменена с учётом закрытых
репозиториев:
\small{\begin{lstlisting}
def allowed_to_with_private_repository?(action, context, options={}, &block)
  if (:browse_repository == action || :view_changesets == action) &&
        context.repository.is_private 
      return allowed_to?(:view_private_repositories, context, options,
      &block)       
  end
end
\end{lstlisting}}
При условии, что проверяемое право доступа \textit{action} сопадает с
перехватываемыми (\textit{browse\_repository } и \textit{view\_changesets}) и
репозиторий является закрытым, производится проверка на право доступа к
закрытым репозиториям.

Результатом разработки стал плагин, позволяющий осуществлять контроль доступа к
закрытым репозиториям. Плагин вносит следующие изменения:
\begin{itemize}
  \item флаг в свойствах репозитория, определяющий закрытость;
  \item право доступа на просмотр закрытых репозиториев;
  \item ограничение прав доступа к репозиторию, на основе прав пользователя и
  закрытости репозитория.
\end{itemize}


\section{Рассылка уведомлений о задачах}
В соответствии с требованиями указанными в
п.\ref{definition:due_date_reminder}, плагин должен реализовывать следующий
функционал:
\begin{itemize}
  \item уведомление пользователей в указанные дни;
  \item конфигурирование частоты уведомления через пользовательский интерфейс;
  \item уведомление должно содержать общий список просроченных и приближающихся
  задач;
  \item принудительное уведомление о просроченных задачах раз в сутки;
\end{itemize}
Разработка плагина была разбита на две части: модификация пользовательского
интерфейса и разработка модуля, отвечающего за рассылку задач.

\subsubsection{Модификация пользовательского интерфейса}
В постановке задачи указано, что пользователь должен иметь возможность
настройки параметров уведомления, следовательно требуется:
\begin{itemize}
  \item добавить поле в БД, отвечающее за частоту уведомлений;
  \item добавить элемент ввода в интерфейс;
  \item производить валидацию введённых данных.
\end{itemize}

В БД было добавлено поле \textit{reminder\_notification} в таблицу
\textit{users}. Данное поле хранит строку, в которой содержатся числа,
записанные через запятую и отвечающие за то, в какие дни пользователь должен
быть уведомлен о приближающихся задачах. К примеру значение поля \textit{1,3,5}
указывает, что необходимо уведомить пользователя за 1, за 3 и за 5 дней до
окончания срока задачи. 

При помощи Hook'а \textit{view\_my\_account} поле
\textit{reminder\_notification} было добавлено на страницу настроек
пользователя и при помощи модификации DOM дерева было перенесено в
соответсвующее место. Результат показан на рисунке
\ref{picture:reminder-settings}.
\inspicture{reminder-settings}{Страница пользовательских настроек}{0.8}

Для того, чтобы вводимые данные соответствовали формату поля были созданы
методы, отвечающие за валидацию:
\small{\begin{lstlisting}
def self.valid_reminder_notification?(value)
  value =~ /\A(\d+[\s,]*)+\z/
end
\end{lstlisting}}
Данный метод содержит регулярное выражение, которое возвращает \textit{true},
если значение \textit{value} является набором чисел, разделённых запятой.
Следующим шагом было внесено изменение в метод контроллера, сохраняющего данные
с формы настроек:
\small{\begin{lstlisting}
def check_reminder_input
  if !User.valid_reminder_notification?(params[:user][:reminder_notification])
    flash[:error] = l(:error_reminder_notification_input) return redirect_to
    :action => 'account'
  end
end
\end{lstlisting}}
Во второй строке производится проверка, является ли параметр
\textit{reminder\_notification} правильного формата.
Если параметр не соответствует формату, то во второй строке сохраняется
сообщение об ошибке, для последующего вывода пользователю и на последней строке
происходит перенаправление на текущую страницу, с  целью обновления
представления. Таким образом была реализвона защита от ввода данных
некорректного формата.

\subsubsection{Рассылка уведомлений}
Модуль рассылки уведомлений должен включать в себя шаги, показанные на рисунке
\ref{picture:reminder-plugin}. Данная функциональность была инкапсулирована
соответствующие методы класса \textit{ReminderMailer}.
\inspicture{reminder-plugin}{}{0.4}

Получение задач из БД было реализовано с помощью SQL запроса, который выбирает
задачи по нескольким критериям:
\small{\begin{lstlisting}
"#{IssueStatus.table_name}.is_closed = ?", false]
"#{Issue.table_name}.due_date IS NOT NULL"
"#{Project.table_name}.status = #{Project::STATUS_ACTIVE}"
"#{Issue.table_name}.assigned_to_id IS NOT NULL"
"#{User.table_name}.status = #{User::STATUS_ACTIVE}"
\end{lstlisting}}
В запросе описаны следующие критерии: задача не закрыта, у неё уставлен срок
сдачи и она располагается в активном проекте, также у задачи есть исполнитель,
который является активным. 
\small{\begin{lstlisting}
def self.find_issue
  issues.reject! { |issue| not (issue.remind? or issue.overdue?) }
  issues.sort! { |first, second| first.due_date <=> second.due_date }
end
\end{lstlisting}}
В issues хранятся задачи, полученные, с помощью вышеобозначенного запроса. Во
второй строке данные отфильтровываются и в массиве \textit{issues} остаются
только те, о которых необходимо уведомлять или срок сдачи которых прошёл. В
последней строке производится сортировка по сроку сдачи. Класс \textit{Issue}
был расширен двумя методами, для того, чтобы была возможна фильтрация,
описанная во второй строке:
\small{\begin{lstlisting}
def days_before_due_date
  (due_date - Date.today).to_i
end
\end{lstlisting}}
В данном методе вычисляются дни оставшиеся до срока сдачи задачи.
\small{\begin{lstlisting}
def remind?
   !assigned_to.nil? and
    assigned_to.reminder_notification_array.include?(days_before_due_date)
end
\end{lstlisting}}
Если у задачи нет ответственного, то о ней не нужно уведомлять. В противном
случае у ответственного пользователя запрашиваются настройки уведомления и
происходит проверка необходимости уведомления в сегодняшний день.

Класс \textit{ReminderMailer} был унаследован от класса \textit{Mailer}, для
того, чтобы добавить возможности отсылки писем и их генерации на основе ERB
шаблонов. Метод производящий отсылку уведомлений выглядит следующим образом:
\small{\begin{lstlisting}
def self.send_due_date_notifications
  issues = self.find_issues
  issues.each { |issue| self.insert(data, issue) }
  data.each do |user, projects|
    deliver_due_date_notification(user, projects)
  end
end
\end{lstlisting}}
На второй строке выбирается все задачи, с помощью описанного выше метода. В
третьей строке полученные данные группируются в двухуровневую хеш-таблицу, где
ключами первого уровня являются пользователи, а ключами второго уровня проекты,
значениями которых являются отсортированные задачи. Метод
\textit{deliver\_due\_date\_notification} формирует письмо для каждого из
пользователей и передаёт данные хеш-таблицы в ERB шаблон. Отсылка письма
производится классом Mailer на основе сгенерированного ERB шаблона.

Отсылка писем производится с помощью вызова метода
\textit{ReminderMailer.send\_due\_date\_notifications}. Необходимо настроить
вызов данного метода раз в день. Для ежедневного выполнения данного метода был
использован планировщик задач Cron, который запускает следующую Rake-задачу:
\small{\begin{lstlisting}
namespace :redmine do
  namespace :reminder_plugin do
    task :send_notifications => :environment do
      ReminderMailer.send_due_date_notifications
    end
  end
end
\end{lstlisting}}
В первой и второй строках указывается область видимости задачи. В третьей
строке была создана Rake-задача \textit{send\_notifications}, которая вызывает
метод \textit{send\_due\_date\_notifications}. В конфигурационный файл
планировщика Cron был добавлена следующая строка:
\small{\begin{lstlisting}
0 5 * * * rake redmine:reminder_plugin:send_notifications
\end{lstlisting}}
В данной строке указано, что Rake-задачу под именем
\textit{redmine:reminder\_plugin:send\_notifications} следует запускать каждый
день в 5 утра.

Был разработан плагин, осуществляющий отправку уведомлений о приближающихся
задачах, в соответствии с настройками пользователя, а также производящий
принудительную отсылку уведомлений для просроченных задач. Отсылка уведомлений
осуществляется с помощью планировщика Cron раз в сутки.

\section{Механизм позиционирования календаря}
\inspicture{calendar-not-visible}{Календарь расположен за границами окна}{0.7}
Для выбора дат в Redmine присутсвует элемент <<Календарь>>. При открытии
календаря на устройствах с низким разрешением экрана он может разместиться за
границами экрана, что создаёт неудобства при его использовании. На рисунке
\ref{picture:calendar-not-visible} показан календарь выехавший за границы
экрана. Необходимо исправить данный дефект таким образом, чтобы при открытии
календарь был полностью видим пользователю.

Исправить подобный дефект возможно с помощью стандартной javascript
функции \textit{scrollTo}, которая позволяет программно прокрутить
страницу в место с указанными координатами. Координаты назначения, в которые
необходимо прокрутить страницу, были вычислены при помощи функций,
возвращающих координаты видимой области окна и положение календаря.

Подобное решение обладает недостатком: прокрутка происходит мгновенно и
пользователь будет вынужден вновь искать на странице календарь, что является не
лучшим решением с точки зрения удобства использования. Было произведено
усовершенствование, позволяющее сделать прокрутку страницы плавной.
Библиотека Prototype, поставляемая с Redmine, предоставляет функции,
обеспечивающие возможность создания анимации. В рамках задачи, были
использованы две функции: \textit{Effect.Parallel} и \textit{Effect.Tween}.
Было создано две функции \textit{Tween}, производящие плавную прокрутка окна до
указанной точки по оси ординат и по оси абсцисс. Эффекты были применены
параллельно с помощью функции \textit{Parallel}.

Механизм позиционирования был выполнен в виде патча, исходный код
которого помещён в приложении
\ref{appendix:ensure-that-calendar-is-visible.patch}.

\section{Изображения-ссылки в боковой панели}
Задача состоит, чтобы разместить изображения-ссылки в боковой панели, которые
будут указывать на интернет-ресурсы. Усовершенствование было выполнено в виде плагина, поскольку система Hook'ов,
позволяет внести изменения в боковую панель способом, предусмотренным
разработчиками. Была произведена регистрация Hook'a
\textit{view\_layouts\_base\_sidebar} и создано частичное представление, в
который были помещены ссылки на три ресурса. Результат работы отображён на
рисунке \ref{picture:sidebar-links}, в котором боковая панель находится в
правой части под надписью ``We Recommend''.
\inspicture{sidebar-links}{Изображения-ссылки в боковой панели}{0.7}



\section{Возможность указать тип задачи при составлений обзора кода}

\inspicture{code-review}{Окно для добавления обзора кода}{0.7}

\section{Расширение интеграции с системами контроля версий}

\inspicture{repository-settings}{Глобальные настройки репозиториев}{0.7}



%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "diploma"
%%% End:
