\lstset{language=Ruby}

\chapter{Реализация расширений}

\section{Ruby on Rails}
Ruby on Rails "--- это фреймворк для построения веб-приложений в соответствии с
шаблоном проектирования Модель-Вид-Контроллер (MVC). Rails приложение состоит
из трёх ключевых уровней.

Уровень представления состоит из файлов-шаблонов, которые отвечают за
отображение данных приложения. Шаблоны могут быть различных видов, но основной
формат "--- это HTML со вставками на языке Ruby, за генерацию которого отвечает
движок ERB языка Ruby.

Уровень модели представляет доменную область и инкапсулирует бизнес-логику
приложения. Классы модели в Rails приложении могут быть связаны с базой данных
(БД) через ActiveRecord. ActiveRecord даёт возможность работать со строками в
БД как с обычными объектами, а также дополнять эти объекты методами
бизнес-логики.

Контроллеры отвечают за обработку входящих HTTP запросов и формирование ответа.
Зачастую, ответ возвращается в HTML, но также возможна генерация ответа в XML,
JSON, PDF и других форматах. Контроллеры генерируют ответ на основе данных,
полученных из моделей, и соответствующих шаблонов представления.
% временное изображение, будет что-то похожее.
\inspicture{rails-architecture}{Архитектура Rails приложения}{1}

\subsubsection{Структура Rails приложения}
Rails приложение организовано в нескольких директорий, предназначенных для
хранения следующих компонентов:
\begin{itemize}
\item app/controllers: классы контроллеров;
\item app/helpers: вспомогательные (Helper) классы для шаблонов представления,
моделей и контроллеров;
\item app/models: классы модели;
\item app/view: шаблоны представления;
\item app/view/layouts: макеты для шаблонов представления;
\item config: конфигурация приложения, в том числе конфигурация БД и различных
окружений;
\item db: данные связанные с БД, к примеру схема БД и файлы миграции;
\item lib: библиотеки и различные файлы с классами;
\item public: статические данные: javascript, css, HTML файлы и изображения;
\item script: файлы скриптов для запуска различных инструментов;
\item test: классы, предназначенные для тестирования приложения;
\item vendor: сторонние библиотеки.
\end{itemize}
В папке vendor/plugins содержатся плагины Redmine. Структура директории с
плагином во многом схожа с Rails, поскольку плагин является миниатюрным Rails
приложением. Директория плагина включает папки, содержание которых
было описано выше: app, db, config, test, lib. А также папка assets, назначение
которой соответствует директории public.


\section{Ограничение доступа к отдельным вики-страницам}
В данном пункте детально описана реализация плагина,
предоставляющего функционал в соответсвии с требованиями, опеределёнными
в пункте \ref{definition:private_wiki}.

\subsection{Регистрация плагина}
Redmine регистрирует плагин, получая информацию из файла init.rb, находящегося
в директории /vendor/plugins/redmine\_<имя\_плагина>. Плагин был назван
private\_wiki и соответвенно была создана соответствующая директория с файлом
init.rb следующего содержания:

\small{
\begin{lstlisting}
Redmine::Plugin.register :redmine_private_wiki do
  name 'Private Wiki'
  author 'Oleg Kandaurov'
  description 'Adds private pages to wiki'
  version '0.0.1'
end
\end{lstlisting}}

Redmine::Plugin.register "--- функция, которая производит регистрацию плагина
под именем redmine\_private\_wiki. На остальных строках указана информация о
плагине:
\begin{itemize} 
  \item name: имя плагина, отображаемое пользователю;
  \item author: имя автора плагина;
  \item description: краткое описание плагина;
  \item version: версия плагина.
\end{itemize}

\subsection{Миграция базы данных} 
Механизм миграции "--- это часть Rails модуля ActiveRecord, при помощи которого
разработчикам предоставляется удобный доступ изменения БД. Главное преимущество
механизма миграции, что он не зависит от БД, поскольку трансформации
записываются используя специальный формат. Файл миграции могут быть применены к
БД с помощью запуска команды rake db:migrate. Благодаря механизму миграции
возможно использование различных БД для разных сред, к примеру, SQLite3 для
разработки и MySQL для тестовой среды. Разработчики Redmine предусмотрели
возможность использования механизма миграции плагинами.

В БД должна храниться информация о том является страница закрытой или нет. То
есть необходимо определить место для хранения данной информации и
соответсвующим образом изменить БД. Путём изучения БД было выявлено, что данные
о вики-странице хранятся в таблице wiki\_pages. Было принято решение, добавить
в вышеназванную таблицу дополнительный столбец, определяющий закрытость
страницы. Для изменения БД был использовован механизм миграции. Данные о
миграции были размещены в файле db/migrate/0001\_add\_private\_wiki.rb со
следующим содержанием:

\small{
\begin{lstlisting}
class AddPrivateWiki < ActiveRecord::Migration
  def self.up
    add_column(:wiki_pages, "private", :boolean, :default => false)
  end
  def self.down
    remove_column(:wiki_pages, "private")
  end
end
\end{lstlisting}}
Класс миграции должен быть унаследован от ActiveRecord::Migration, а также в
нём должны быть определены два метода: up и down. Первый метод описывает
действия при применении миграции, а второй при её отмене. При применении
миграции осуществляется добавление столбца private, имеющего boolean тип, в
таблицу wiki\_pages. А при отмене миграции столбец private будет удалён из
таблицы wiki\_pages. Применение миграции осуществляется с помощью вызова
команды rake db:migrate\_plugins.

\subsection{Система контроля доступа}
Redmine предоставляет гибкую систему контроля доступа на основе ролей. Роль
включает в себя определённое количество прав доступа, которые сгруппированы в
соответствии с назначением, по модулям. Гибкость заключается в том, что
администраторы имеют возможность создавать дополнительные роли, а также
назначать пользователю разные роли в зависимости от проекта.

В рамках решаемой задачи, необходимо создать право доступа определяющее
видимость закрытых страницам. Системой плагинов Redmine предусмотрена
возможность регистрации дополнительных прав доступа. Следующие изменения были
внесены в файл init.rb:

\small{
\begin{lstlisting}
project_module :wiki do
  permission :view_private_wiki_pages, {}
end
\end{lstlisting}}
Метод project\_module :wiki добавляет нижестоящее право доступа в модуль wiki.
Во второй строке определяется новое право доступа с именем
view\_private\_wiki\_pages.  


\subsection{Расширение классов во время выполнения}
\label{section:metaprogramming} 
Метапрограммирование "--- это процесс написание компьютерных программ,
способных создавать и изменять другие программы или самих себя на этапе
компиляции или во время выполнения. Ruby "--- динамический язык, который
предоставляет широкие возможности для метапрограммирования. В частности,
приложения на Ruby могут программно изменять свою структуру во время
выполнения. Метапрограммирование в Ruby может использоваться для следующих
целей:
\begin{itemize}
  \item модификация методов и перехват вызовов;
  \item генерация классов и методов по параметрам;
  \item автоматическая сериализация;
  \item интерактивная помощь.
\end{itemize}

Задача заключается в том, чтобы изменить бизнес-логику, связанную с проверкой
доступа к вики-страницам. Право доступа, отвечающее за видимость вики-страниц
называется view\_wiki\_pages. В бизнес-логике вышеназванное право доступа
используется в классе WikiPage в методе visible?:

\small{
\begin{lstlisting}
def visible?(user=User.current)
  !user.nil? && user.allowed_to?(:view_wiki_pages, project)
end
\end{lstlisting}}
Метод allowed\_to? класса User проверяет наличие у пользователя права на
просмотр вики-страниц в заданном проекте. Стало возможным сформулировать
задачу точнее: требуется с помощью возможностей метапрограммирования изменить
поведение метода visible? в классе WikiPage таким образом, чтобы дополнительно
у пользователя проверялось право доступа на просмотр закрытых страниц.

\subsubsection{Расширение классов во время выполнения} 
Один из способов изменить поведение класса "--- расширить его с помощью модуля.
Модуль представляет собой набор методов и констант.
Класс может быть расширен путём вызова метода include, в параметрах которого
содержится модуль для расширения. Разработчики Redmine советуют выполнять
расширение в функции обратного вызова to\_prepare в классе Dispatcher. Функция
to\_prepare вызывается единожды при запуске приложение или при каждом запросе,
в зависимости от того, в каком режиме запущено приложение. Код, осуществляющий
расширение, был помещён в файл init.rb:

\small{
\begin{lstlisting}
require 'private_wiki/wiki_patch'
require 'dispatcher'
Dispatcher.to_prepare :redmine_private_wiki do
  unless WikiPage.included_modules.include? PrivateWiki::WikiPatch
    WikiPage.send(:include, PrivateWiki::WikiPatch)
  end 
end
\end{lstlisting}}
В первых двух строках производится подключение файлов с модулем для расширения
и с классом Dispatcher cоответсвенно. Dispatcher.to\_prepare регистрирует
функцию обратного вызова. На следующей строке идёт проверка, недопускающая
повторное включение модуля. И на пятой строке производится включение модуля
PrivateWiki::WikiPatch в класс WikiPage.

Модуль был размещён в файле private\_wiki/wiki\_patch:
\small{
\begin{lstlisting}
module PrivateWiki
  module WikiPatch
    def self.included(base)
      base.send(:include, InstanceMethods)
      base.class_eval do
      end
    end
    module InstanceMethods
    end
  end
end
\end{lstlisting}}
Метод included вызывается при включении модуля в класс, в параметр base
которого будет помещён расширяемый класс. base.send(:include, InstanceMethods)
расширяет класс модулем, методы которого будут доступны экземплярам
расширяемого класса, а методы размещенные внутри блока base.class\_eval могут
быть вызваны на классе.


\subsubsection{Перехват вызовов метода}
Модуль ActiveSupport содержит метод alias\_method\_chain, позволяющий
перехватывать обращение к заданному методу. Рассмотрим его работу на следующем
примере:
\small{
\begin{lstlisting}
base.class_eval do
  alias_method_chain :visible?, :private_wiki
end
\end{lstlisting}}
% Следующее лучше показать картинкой.
При вызове alias\_method\_chain создаётся метод
visible\_without\_private\_wiki в классе WikiPage. Данный метод, осуществляет
проброс вызова на оригинальный метод visible?. А обращение к методу visible?
перенаправляет вызывающего на метод visible\_with\_private\_wiki. Поскольку
метода visible\_with\_private\_wiki не существует, он был создан.
\small{
\begin{lstlisting}
module InstanceMethods
  def visible_with_private_wiki?(user)  
    if self.private and !is_private_page_visible?(project, user)
      return false
    end
    visible_without_private_wiki?(user)
  end
end
\end{lstlisting}}
If-условие производит проверку, если страница является закрытой и пользователь
не имеет прав на просмотр скрытых страниц, то метод возвращает false, в
противном случае вызывается оригинальный метод visible?. Таким образом были
внесены изменения в логику проверки видимости вики-страниц в соответствии с
требованиями.



% 
% 
% \subsection{Контроллеры и маршрутизация}
% Диспетчер отвечает за разбор приходящих HTTP запросов и g 
% \inspicture{mvc-rails}{Архитектура Rails приложения}{0.5}
% Следующим шагом необходимо найти контроллер и шаблон представления, отвечающий
% за генерацию вики-страниц. Запустив приложение, увидим, что вики-страница под
% именем `page 1`, в проекте под именем `my\_project` имеет следующий адрес:
% /projects/my\_project/wiki/page\_1. Теперь определим, какой контроллер
% отвечает за обработку запроса на отображение вики-страницы. Для этого
% в консоли, в папке проекта, вызовем команду rake routes, которая выведет список
% всех маршрутов(в выводе опущена несущественная часть):
% \small{
% \begin{lstlisting}
% ...
% GET    /projects/:project_id/wiki       {:action=>"show", :controller=>"wiki"}
% GET    /projects/:project_id/wiki/index {:action=>"index", :controller=>"wiki"}
% GET    /projects/:project_id/wiki/:id   {:action=>"show", :controller=>"wiki"}
% PUT    /projects/:project_id/wiki/:id   {:action=>"update", :controller=>"wiki"} 
% DELETE /projects/:project_id/wiki/:id   {:action=>"destroy", :controller=>"wiki"} 
% ...
% \end{lstlisting}}
% Первый столбец указывает на тип HTTP запроса, а второй столбец на формат
% адресной строки. На основе этих двух параметров диспетчер запросов выбирает
% контроллер и метод, указанный в третьем столбце, в который он перенаправит
% запрос. Легко заметить, что за генерацию искомой страницы отвечает метод show в
% контроллере под именем wiki. Rails активно использует конвенции по
% именованию. Из этих конвенций следует, что класс контроллера должен называться
% WikiController и распологаться в директории /app/controllers.
% 
% \subsubsection{Запрет доступа к вики-странице}
% Для того, чтобы скрытая вики-страница не отображалась пользователям без
% соответствующих прав, перехватим вызов метода show в контроллере
% WikiController, с помощью техник, описанных в пунктах
% \ref{section:module_inclusion} и \ref{section:alias_method_chain}:
% \small{
% \begin{lstlisting}
% ...
% def show_with_private_wiki
%   if not @page.visible? {return render_403}
%   show_without_private_wiki
% end
% ...
% \end{lstlisting}}
% Если просматривая страница должна быть скрыта от пользователя, то
% сообщаем ему, что доступ к просмотру страницы закрыт, в противном случае
% выполняем оригинальный метод show.
% 
% \subsubsection{Смена видимости вики-страницы}
% На данном этапе требуется создать метод в контроллере, который будет изменять
% поле private для вики-страницы и сохранять изменения в БД. В первую очередь
% необходимо изменить таблицу маршрутизации, для этого был создан файл
% config/routes.rb со следующим содержанием:
% \small{
% \begin{lstlisting}
% ActionController::Routing::Routes.draw do |map|
%   map.resources :projects do |project|
%     project.private_wiki_change_privacy 
%         'wiki/:id/change_privacy/:private', 
%         :controller => 'wiki', :action => 'change_privacy',  :conditions =>
%             {:method => :post}
%   end
% end
% \end{lstlisting}}
% В первой и второй строке В третьей строке создаётся маршрут под названием 
% private\_wiki\_change\_privacy. И в следующих строках указывается, что запрос,
% адрес назначения которого соответствует шаблону
% wiki/:id/change\_privacy/:private, следует перенаправить в контроллер c
% именем wiki в метод change\_privacy. Следует заметить, что :private и :id
% являются параметрами, которые доступны в переменной params в контроллере. 
% 
% Следующим действием будет создание метода change\_privacy в контроллере
% WikiController:
% \small{
% \begin{lstlisting}
% def change_privacy
%   find_existing_page
%   @page.update_attribute :private, params[:private]
%   redirect_to :action => 'show', :project_id => @project, :id => @page.title
% end
% \end{lstlisting}}
% Во второй строке вызывается метод, который выполняет различные проверки и
% присваивает переменной @page объект, связанный с текущей вики-страницей в БД.
% На третьей строке объекту устанавливается атрибут private, полученный из
% запроса, и изменения заносятся в БД. В последней строке происходит
% перенаправление в метод контроллера, отвечающий за отображение вики-страницы.
% 
% \subsection{Redmine Hooks}
% Redmine поддерживает концепцию Hook'ов. Hook "--- это API, который позволяет
% расширить функциональность Redmine. При помощи Hook'a автор плагина может
% зарегистрировать функции обратного вызова, которые вызовутся одна за другой,
% когда исполнится определённый код в Redmine. В документации Redmine есть список
% Hook'ов, но он не полный и авторы Redmine советуют самостоятельно просмотреть
% интересующую часть кода на предмет наличия в ней Hook'ов.
% 
% При вызове Hook'a он исполняет зарегистрированные функции обратного вызова. Эти
% функции содержат только один параметр "--- хэш, содержащий информацию
% о контексте вызова. Вышеназванный хэш предоставляет данные, необходимые для
% выполнения операций в функциях обратного вызова.
% 
% Redmine предоставляет три вида Hook'ов: для шаблонов представления, модели и
% контроллеров. Разработчики Redmine советует использовать вместо двух последних
% видов Hook'ов механизмы фреймворка Ruby On Rails и языка Ruby, рассмотренные
% ранее. Разберём работу Hook'ов для шаблонов представления.
% 
% Контекст, передаваемый в Hook для представления содержит следующие данные:
% \begin{itemize}
%   \item controller: ссылка на контроллер который производит генерацию
%   текущего шаблона представления;
%   \item project: текущий проект, если таковой установлен контроллером;
%   \item request: объект, содержащий информацию о веб-запросе;
%   \item дополнительные параметры, специфичные для Hook'a, которые могут
%   быть найдены в вызове метода call\_hook на шаблоне представления.
% \end{itemize}
% Hook'и шаблонов представления исполняются при генерации шаблона. То есть этот
% механизм позволяет автору встраивать HTML-код в места, определённые
% расположением соответствующего Hook'а. Значение возвращаемое функцией обратного
% вызова преобразуется в строку и встраивается в представление.
% 
% \subsubsection{Создание Hook'а для представления}
% Для того, чтобы найти шаблон представления, необходимо посмотреть на метод show
% в классе WikiController(несущественная часть опущена).
% \small{
% \begin{lstlisting}
% def show
%   ...
%   render :action => 'show'
% end
% \end{lstlisting}
% } 
% render :action => 'show' указывает на то, что генерируемый шаблон
% представления называется show. В соответствии с конвенциями именования, его
% следует искать в директории /app/views/wiki\_controller в файле show.html.erb.
% Hook'и являются вызовом метода call\_hook, которые в данном шаблоне
% отсутствуют. Это значит то, что Hook'и специфичные для данного представления
% отсутствуют и нужно искать глобальные, присутствующие на всех страницах. Все
% шаблоны в Redmine генерируются внутри главного макета, находящегося в файле
% /app/views/layouts/base.html.erb. В данном макете, определены несколько
% Hook'ов:
% \begin{itemize}
%   \item view\_layouts\_base\_html\_head: определён внутри секции head HTML
%   документа и предназначен для подключения javascript библиотек и css стилей;
%   \item view\_layouts\_base\_sidebar: добавляет элементы в
%   боковую панель;
%   \item view\_layouts\_base\_content: добавляет элементы в главную область
%   страницы;
%   \item view\_layouts\_base\_body\_bottom: добавляет элементы в конец секции
%   body.
% \end{itemize}
% Из перечисленных Hook'ов, для наших целей в большей степени подходят
% view\_layouts\_base\_html\_head и view\_layouts\_base\_body\_bottom.
% Перейдём к процессу создания функции обратного вызова для вышеперечисленных
% Hook'ов. Создадим файл lib/private\_wiki/hooks.rb внутри директории плагина и
% укажем, чтобы Redmine загружал его при регистрации плагина поместив require
% 'private\_wiki/hook' в начало файла init.rb. В самом файле hooks.rb напишем
% следующее:
% \small{
% \begin{lstlisting}
% module PrivateWiki
%   class PrivateWikiHook < Redmine::Hook::ViewListener
%     render_on :view_layouts_base_html_head, :partial => 'hooks/html_header'
%     render_on :view_layouts_base_body_bottom, :partial => 'hooks/body_bottom'
%   end
% end
% \end{lstlisting}
% }
% \begin{itemize}
%   \item module PrivateWiki задаёт область видимости создаваемого класса;
%   \item Redmine::Hook::ViewListener класс, от которого должен быть унаследован
%   класс, регистрирующий Hook'и;
%   \item render\_on :view\_layouts\_base\_html\_head, :partial => 'hooks/html\_header'
%  регистрирует функцию обратного вызова, которая генерирует частичный шаблон представления с
% именем hooks/html\_header при вызове Hook'а view\_layouts\_base\_html\_head.
% \end{itemize}
% 
% В соответствии с конвенциями именования, частичные шаблоны представления,
% упомянутые выше, должны располагаться в директории app/views/hooks в файлах
% \_html\_header.html.erb \_body\_bottom.html.erb. В файле
% \_html\_header.html.erb реализуем подключение css-стилей следующим образом:
% \small{
% \begin{lstlisting}
% <% if controller and 
%   controller.class.name == 'WikiController' and 
%   controller.action_name == "show" %>
%     <%= stylesheet_link_tag "private_wiki.css", 
%       :plugin => "redmine_private_wiki", 
%       :media => "screen" %>
% <% end %>
% \end{lstlisting}
% }
% В первых трёх строках указано, что будем осуществлять подключение стиля только
% если процесс генерации страницы был инициирован контроллером WikiController и
% методом show. Подключение файлы с css стилями осуществляется с помощью Helper'а
% stylesheet\_link\_tag. Механизм Helper'ов позволяет выделить повторяющийся код
% в методы и получить преимущества от многократного использования кода. В Helper
% передаются несколько параметров указывающих, где располагается файл стиля. В
% данном случае файл c css стилями должен быть расположен в директории
% assets/stylesheets/private\_wiki.css. На данном этапе можно запустить Redmine и
% убедиться, что файл стилей подключается только на вики-страницах.
% 
% \subsubsection{Размещение элементов на странице}
% 
% 
% 
% 
% \section{Улучшенный механизм позиционирования всплывающего календаря}
% 
% \section{Возможность указать тип задачи при составлений обзора кода}
% 
% \section{Улучшенная система навигации между страницами просмотра изменений}
% % Патч такой-то исходный код в приложении
% % ~\ref{appendix:back-link-to-rev-from-diff.patch})
% 
% \section{Расширение интеграции с системами контроля версий}
% 
% \section{Рассылка уведомлений о приближающихся и просроченных задачах}
% 
% \section{Ограничение доступа к репозиториям}
% 
% \section{Изображения-ссылки в боковой панели}



%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "diploma"
%%% End: 
