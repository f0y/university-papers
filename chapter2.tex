\lstset{language=Ruby}

\chapter{Реализация расширений}
\label{section:implementation}

\section{Ограничение доступа к отдельным вики-страницам}
\label{section:private_wiki}
В данном пункте детально описана реализация плагина, предоставляющего
функционал в соответствии с требованиями, опеределёнными в пункте
\ref{definition:private_wiki}.

\subsection{Регистрация плагина}
 
Rails приложение организовано в нескольких директорий, предназначенных для
хранения следующих компонентов:

\begin{itemize}
\item \textit{app/controllers} классы контроллеров;
\item \textit{app/helpers} вспомогательные (Helper) классы для шаблонов
представления, моделей и контроллеров;
\item \textit{app/models} классы модели;
\item \textit{app/view} шаблоны представления;
\item \textit{app/view/layouts} макеты для шаблонов представления;
\item \textit{config} конфигурация приложения, в том числе конфигурация БД и
различных окружений;
\item \textit{db} данные связанные с БД, к примеру схема БД и файлы миграции;
\item \textit{lib} библиотеки и различные файлы с классами;
\item \textit{public} статические данные: javascript, css, HTML файлы и
изображения;
\item \textit{script} файлы скриптов для запуска различных инструментов;
\item \textit{test} классы, предназначенные для тестирования приложения;
\item \textit{vendor} сторонние библиотеки.
\end{itemize}
В папке \textit{vendor/plugins} содержатся плагины Redmine. Структура
директории с плагином во многом схожа с Rails, поскольку плагин является
миниатюрным Rails приложением. Директория плагина включает папки, содержание
которых было описано выше: \textit{app}, \textit{db}, \textit{config},
\textit{test}, \textit{lib}.
А также папка \textit{assets}, назначение которой соответствует директории
\textit{public}.

Redmine регистрирует плагин, получая информацию из файла init.rb, находящегося
в директории \textit{/vendor/plugins/redmine\_<имя\_плагина>}. Плагин был
назван \textit{private\_wiki} и соответственно была создана директория с файлом
\textit{init.rb} следующего содержания:
\small{\begin{lstlisting}
Redmine::Plugin.register :redmine_private_wiki do
  name 'Private Wiki'
  author 'Oleg Kandaurov'
  description 'Adds private pages to wiki'
  version '0.0.1'
end
\end{lstlisting}}
\textit{Redmine::Plugin.register} "--- функция, которая производит регистрацию
плагина под именем \textit{redmine\_private\_wiki}. На остальных строках
указана информация о плагине:
\begin{itemize} 
  \item \textit{name} имя плагина, отображаемое пользователю;
  \item \textit{author} имя автора плагина;
  \item \textit{description} краткое описание плагина;
  \item \textit{version} версия плагина.
\end{itemize}

\subsection{Миграция базы данных} 
\label{section:migration}
Механизм миграции "--- это часть Rails модуля ActiveRecord, при помощи которого
разработчикам предоставляется удобный способ изменения БД. Главное преимущество
механизма миграции в том, что он не зависит от БД, поскольку трансформации
записываются в специальном формате. Файл миграции может быть применён к БД с
помощью запуска команды \textit{rake db:migrate}. Благодаря механизму миграции,
возможно использование различных БД для разных сред без изменения файлов
миграции. К примеру, SQLite3 для разработки и MySQL для тестовой среды.

В БД должна храниться информация о том является страница закрытой или нет.
Следовательно необходимо определить место для хранения данной информации и
соответствующим образом изменить БД. В процессе изучения БД было выявлено, что
данные о вики-странице хранятся в таблице \textit{wiki\_pages}. Было принято
решение, добавить в вышеназванную таблицу дополнительный столбец, определяющий
закрытость страницы. Для изменения БД был использовован механизм миграции,
поскольку разработчики Redmine предусмотрели возможность использования
механизма миграции в плагинах. Данные о миграции были размещены в файле
\textit{db/migrate/0001\_add\_private\_wiki.rb} со следующим содержанием:
\small{\begin{lstlisting}
class AddPrivateWiki < ActiveRecord::Migration
  def self.up
    add_column(:wiki_pages, "private", :boolean, :default => false)
  end
  def self.down
    remove_column(:wiki_pages, "private")
  end
end
\end{lstlisting}}
Класс миграции должен быть унаследован от \textit{ActiveRecord::Migration}, а
также в нём должны быть определены два метода: \textit{up} и \textit{down}.
Первый метод описывает действия при применении миграции, а второй при её
отмене. При применении миграции осуществляется добавление столбца
\textit{private}, имеющего \textit{boolean} тип, в таблицу
\textit{wiki\_pages}. А при отмене миграции столбец \textit{private} будет
удалён из таблицы \textit{wiki\_pages}. Применение миграции осуществляется с
помощью вызова команды \textit{rake db:migrate\_plugins}.

\subsection{Система контроля доступа}
\label{section:access_control}
Redmine предоставляет гибкую систему контроля доступа на основе ролей. Роль
включает в себя определённое количество прав доступа, которые сгруппированы в
соответствии с назначением, по модулям. Гибкость заключается в том, что
администраторы имеют возможность создавать дополнительные роли, а также
назначать пользователю разные роли в зависимости от проекта.

В рамках решаемой задачи, необходимо создать право доступа определяющее
видимость закрытых страниц. Системой плагинов Redmine предусмотрена
возможность регистрации дополнительных прав доступа. Следующие изменения были
внесены в файл \textit{init.rb}:
\small{
\begin{lstlisting}
project_module :wiki do
  permission :view_private_wiki_pages, {}
end
\end{lstlisting}}
Метод \textit{project\_module} добавляет право доступа в модуль \textit{wiki}.
Во второй строке определяется новое право доступа с именем
\textit{view\_private\_wiki\_pages}.
После внесения данных изменений, на странице редактирования ролей, будет
отображено данное право доступа с именем ``View Private Wiki Pages''

\subsection{Расширение классов во время выполнения}
\label{section:metaprogramming} 
Gриложения на Ruby способны программно изменять свою структуру во время
выполнения. Метапрограммирование в Ruby может использоваться для следующих
целей:
\begin{itemize}
  \item модификация методов и перехват вызовов;
  \item генерация классов и методов по параметрам;
  \item автоматическая сериализация;
  \item интерактивная помощь.
\end{itemize}

Задача заключается в том, чтобы изменить бизнес-логику, связанную с проверкой
доступа к вики-страницам. Право доступа, отвечающее за видимость вики-страниц
называется \textit{view\_wiki\_pages} и используется в классе \textit{WikiPage}
в методе
\textit{visible?}:
\small{\begin{lstlisting}
def visible?(user=User.current)
  !user.nil? && user.allowed_to?(:view_wiki_pages, project)
end
\end{lstlisting}}
Метод \textit{allowed\_to?} класса \textit{User} проверяет наличие у
пользователя права на просмотр вики-страниц в заданном проекте. На основе
данной иноформации задача была переформулирована: требуется с помощью
возможностей метапрограммирования изменить поведение метода \textit{visible?} в
классе \textit{WikiPage} таким образом, чтобы у пользователя также проверялось
право доступа на просмотр закрытых страниц.

\subsubsection{Расширение классов во время выполнения} 
Один из способов изменить поведение класса "--- расширить его с помощью модуля.
 Класс может быть расширен
путём вызова метода \textit{include}, в параметрах которого содержится модуль
для расширения. Разработчики Redmine советуют выполнять расширение модулем в
функции обратного вызова \textit{to\_prepare} в классе \textit{Dispatcher}.
Функция \textit{to\_prepare} вызывается единожды при запуске приложение или при
каждом запросе, в зависимости от того, в каком режиме запущено приложение. Код,
осуществляющий расширение, был помещён в файл \textit{init.rb}:
\small{\begin{lstlisting}
require 'private_wiki/wiki_patch' require 'dispatcher'
Dispatcher.to_prepare :redmine_private_wiki do
  unless WikiPage.included_modules.include? PrivateWiki::WikiPatch
    WikiPage.send(:include, PrivateWiki::WikiPatch)
  end 
end
\end{lstlisting}}
В первых двух строках производится подключение файлов с модулем для расширения
и с классом \textit{Dispatcher} cоответсвенно. \textit{Dispatcher.to\_prepare}
регистрирует функцию обратного вызова. На следующей строке идёт проверка,
недопускающая повторное включение модуля. И на пятой строке производится
включение модуля \textit{PrivateWiki::WikiPatch} в класс \textit{WikiPage}.

Модуль был размещён в файле \textit{private\_wiki/wiki\_patch}:
\small{\begin{lstlisting}
module PrivateWiki
  module WikiPatch
    def self.included(base)
      base.send(:include, InstanceMethods)
      base.class_eval do
      end
    end
    module InstanceMethods
    end
  end
end
\end{lstlisting}}
Метод \textit{included} вызывается при включении модуля в класс, в параметр
\textit{base} которого будет помещён расширяемый класс. Вызов метода
\textit{base.send(:include, InstanceMethods)} расширяет класс модулем, методы
которого будут доступны экземплярам расширяемого класса, а методы размещенные
внутри блока \textit{base.class\_eval} будут доступны из класса.

\subsubsection{Перехват вызовов метода}
Модуль ActiveSupport содержит метод \textit{alias\_method\_chain}, позволяющий
перехватывать обращение к заданному методу. Рассмотрим его работу на следующем
примере, выполняющем перехват метода \textit{visible?}:
\small{\begin{lstlisting}
base.class_eval do
  alias_method_chain :visible?, :private_wiki
end
\end{lstlisting}}
При вызове \textit{alias\_method\_chain} создаётся метод
\textit{visible\_without\_private\_wiki} в классе \textit{WikiPage}. Данный
метод, осуществляет проброс вызова на оригинальный метод \textit{visible?}. А
обращение к методу \textit{visible?} перенаправляет вызывающего на метод
\textit{visible\_with\_private\_wiki}. То есть стало возможным, контролировать
вызов метода \textit{visible?}.

Вызов метода \textit{visible?} будет перенаправлен на метод
\textit{visible\_with\_private\_wiki}, который следует определить
самостоятельно:
\small{\begin{lstlisting}
module InstanceMethods
  def visible_with_private_wiki?(user)
    if self.private and !is_private_page_visible?(project, user)
      return false
    end
    visible_without_private_wiki?(user)
  end
end
\end{lstlisting}}
If-условие производит проверку, если страница является закрытой и пользователь
не имеет прав на просмотр скрытых страниц, то метод возвращает \textit{false},
в противном случае вызывается оригинальный метод \textit{visible?}. Таким
образом были внесены изменения в логику проверки видимости вики-страниц.

\subsection{Маршрутизация}
\label{section:routing}
Запрос, поступающий в Rails приложение проходит несколько стадий обработки,
отображенных на рисунке \ref{picture:rails-request-processing}.
В начале запрос попадает в сервер приложений, который незамедлительно
возвращает ответ, если запрашивается статический файл, а в противном случае
перенаправляет запрос в \textit{Dispatcher}. \textit{Dispatcher} производит
разбор входящего запроса и на основе таблицы маршрутизации перенаправляет его в
соответствующий контроллер.
Контроллер генерирует ответ на основе шаблонов вида. После окончания работы
контроллера, Dispatcher отправляет ответ инициатору запроса.

\inspicture{rails-request-processing}{Обработка запроса Rails приложением}{0.6}

Задача разработки плагина включает в себя изменение представления, что
подразумевает внесение изменений в шаблона представления и контроллер. В первую
очередь необходимо определить определить контроллер обрабатывающий запрос на
отображение вики страницы. Вики-страница под именем \textit{page1}, в проекте
под именем \textit{my\_project} имеет следующий адрес
\textit{projects/my\_project/wiki/page1}.
Контроллер, обрабатывающий данный запрос, может быть определён на основе
таблицы маршрутизации, вызываемой по команде \textit{rake routes} (в выводе
опущена несущественная часть):
\small{\begin{lstlisting}
GET    /projects/:project_id/wiki       {:action=>"show", :controller=>"wiki"}
GET    /projects/:project_id/wiki/index {:action=>"index", :controller=>"wiki"}
GET    /projects/:project_id/wiki/:id   {:action=>"show", :controller=>"wiki"}
PUT    /projects/:project_id/wiki/:id   {:action=>"update",
:controller=>"wiki"} DELETE /projects/:project_id/wiki/:id  
{:action=>"destroy", :controller=>"wiki"}
\end{lstlisting}}
Первый столбец указывает на тип HTTP запроса, а второй определяет формат
адресной строки. На основе данных параметров \textit{Dispatcher} выбирает метод
контроллера, указанный в третьем столбце, в который будет перенаправлен запрос.
Легко заметить, что в данном случае, за генерацию запроса отвечает метод
\textit{show} в контроллере под именем \textit{wiki}. Rails активно использует
конвенции по именованию.
Из этих конвенций следует, что класс контроллера должен называться
\textit{WikiController} и располагаться в директории \textit{/app/controllers}.

\subsubsection{Добавление маршрута}
В соответствии с требованиями, на вики-странице должен располагаться элемент,
отвечающий за скрытие/открытие вики-страницы. Элемент должен посылать запрос,
который будет изменять состояние страницы, а значит необходимо добавить
маршрут, по которому будет проходить запрос. Для этого был создан файл
\textit{config/routes.rb} со следующим содержанием:
\small{\begin{lstlisting}
ActionController::Routing::Routes.draw do |map|
  map.resources :projects do |project|
    project.private_wiki_change_privacy
        'wiki/:id/change_privacy/:private',
        :controller => 'wiki', :action => 'change_privacy',  :conditions =>
            {:method => :post}
  end
end
\end{lstlisting}}
В первой и второй происходит подготовка к регистрации маршрута. В третьей
строке создаётся маршрут под названием \textit{private\_wiki\_change\_privacy}.
И в следующих строках указывается, что запрос, адрес назначения которого
соответствует шаблону \textit{wiki/:id/change\_privacy/:private}, следует
перенаправить в контроллер c именем \textit{wiki} в метод
\textit{change\_privacy}. Следует заметить, что \textit{private} и \textit{id}
являются параметрами, которые доступны в поле \textit{params} в контроллере.

\subsubsection{Запрещение доступа к вики-странице}
Для того, чтобы скрытая вики-страница не отображалась пользователям без
соответствующих прав, был произведён перехват метода \textit{show} в
контроллере \textit{WikiController}, с помощью техник, описанных в параграфе
\ref{section:metaprogramming}:
\small{\begin{lstlisting}
def show_with_private_wiki
  if not @page.visible? {return render_403} show_without_private_wiki
end
\end{lstlisting}}
На второй строке указано, что если просматриваемая страница скрыта от
пользователя, то следует вывести сообщение о том, что доступ к странице закрыт.
В противном случае, третья строка выполнит оригинальный метод show.

Следующий шаг заключается в создании метода \textit{change\_privacy}, который
будет отвечать за смену статуса вики-страницы:
\small{\begin{lstlisting}
def change_privacy
  find_existing_page @page.update_attribute :private, params[:private]
  redirect_to :action => 'show', :project_id => @project, :id => @page.title
end
\end{lstlisting}}
Во второй строке происходит вызов метода, который выполняет различные проверки
и присваивает переменной \textit{@page} объект, связанный с текущей
вики-страницей в БД.
На третьей строке объекту устанавливается атрибут \textit{private}, полученный
из запроса. На последней строке происходит перенаправление в метод контроллера,
отвечающий за отображение вики-страницы.

На данном этапе пользователь с любыми правами имеет возможность изменить
закрытость страницы. В требованиях указано, что только пользователи с
определёнными правами должны иметь право изменять закрытость страницы. В связи
с этим было добавлено дополнительное право доступа:
\small{\begin{lstlisting}
permission :manage_private_wiki_pages, {:wiki => :change_privacy}
\end{lstlisting}}
\textit{:wiki => :change\_privacy} указывает на то, что только пользователи с
данным правом доступа имеют право вызывать метод \textit{change\_privacy} в
контроллере \textit{wiki}.

\subsection{Redmine Hooks}
\label{section:redmine_hooks}
Redmine поддерживает концепцию Hook'ов.  В документации Redmine есть список
Hook'ов, но он не полный и авторы Redmine советуют разработчикам самостоятельно
просмотреть интересующую часть кода на предмет наличия в ней Hook'ов. При
достижении Hook'a Redmine исполняет зарегистрированные функции обратного
вызова. Функции содержат только один параметр, содержащий информацию о
контексте вызова. Redmine предоставляет три вида Hook'ов: для шаблонов
представления, модели и контроллеров. Разработчики Redmine советуют
использовать вместо двух последних видов Hook'ов механизмы фреймворка Ruby On
Rails и языка Ruby, рассмотренные в параграфе \ref{section:metaprogramming}.

Контекст, передаваемый в Hook шаблона представления содержит следующие данные:
\begin{itemize}
  \item \textit{controller} ссылка на контроллер который производит генерацию
  текущего шаблона представления;
  \item \textit{project} текущий проект, если таковой установлен контроллером;
  \item \textit{request} объект, содержащий информацию о веб-запросе;
  \item дополнительные параметры, специфичные для Hook'a, которые могут
  быть найдены в вызове метода \textit{call\_hook} на шаблоне представления.
\end{itemize}
Значение, возвращаемое зарегистрированной функцией обратного вызова,
преобразуется в строку и встраивается в представление. Таким образом механизм
Hook'ов позволяет встраивать HTML-код в места, определённые расположением
соответствующего Hook'а.

\subsubsection{Создание Hook'а для подключения CSS стилей}
Элементы, которые будут располагаться на вики-странице должны иметь оформление,
описанное в файле с CSS стилем. Необходимо определить местонахождение шаблона
представления, за генерацию которого отвечает метод \textit{show} класса
\textit{WikiController} (несущественная часть опущена).
\small{\begin{lstlisting}
def show
  render :action => 'show'
end
\end{lstlisting}}
\textit{render :action => 'show'} указывает на то, что генерируемый шаблон
представления называется \textit{show}. В соответствии с конвенциями
именования, его следует искать в директории
\textit{/app/views/wiki\_controller} в файле \textit{show.html.erb}.
Вызовы метода \textit{call\_hook} в шаблоне отсутствуют и следовательно
отствуют Hook'и, специфичные для данного представления. Все шаблоны
представления в Redmine генерируются внутри главного макета, находящегося в
файле \textit{/app/views/layouts/base.html.erb}. В данном макете, определены
несколько Hook'ов, в следующих местах страницы:
\begin{itemize}
  \item \textit{view\_layouts\_base\_html\_head} внутри HTML секции head ;
  \item \textit{view\_layouts\_base\_sidebar} в боковой панели;
  \item \textit{view\_layouts\_base\_content} в главной области страницы; 
  \item \textit{view\_layouts\_base\_body\_bottom} в конце HTML секции body.
\end{itemize}
Из перечисленных Hook'ов, для подключения CSS-стиля подходит
\textit{view\_layouts\_base\_html\_head}. В файле \textit{lib/private\_wiki/hooks.rb}
был зарегистрирован Hook и создана функция обратного вызова.
\small{\begin{lstlisting}
class PrivateWikiHook < Redmine::Hook::ViewListener
  render_on :view_layouts_base_html_head, :partial => 'hooks/html_header'
end
\end{lstlisting}}
\textit{Redmine::Hook::ViewListener} "--- класс, регистрирующий Hook'и.
\textit{render\_on} регистрирует функцию обратного вызова, которая генерирует
частичный шаблон представления с именем \textit{hooks/html\_header} при вызове 
Hook'а \textit{view\_layouts\_base\_html\_head}.

В соответствии с конвенциями именования, частичный шаблон представления,
упомянутый выше, должен располагаться в файле
\textit{app/views/hooks/\_html\_header.html.erb}:
\small{\begin{lstlisting}
<% if controller and
  controller.class.name == 'WikiController' and
  controller.action_name == "show" %>
    <%= stylesheet_link_tag "private_wiki.css",
      :plugin => "redmine_private_wiki",
      :media => "screen" %>
<% end %>
\end{lstlisting}}
В первых трёх строках указано, что подключение стиля следует выполнять только
если процесс генерации страницы был инициирован контроллером
\textit{WikiController} и методом \textit{show}. Подключение файла с CSS стилем
осуществляется с помощью Helper'а \textit{stylesheet\_link\_tag}.  В Helper
передаются несколько параметров, указывающих расположение файла стиля. В данном
случае файл c CSS стилем должен быть расположен в директории
\textit{assets/stylesheets/private\_wiki.css}.

\subsubsection{Размещение элементов на странице}
Исходя из требований требуется добавить на вики-страницу элемент, указывающий
на то, что страница закрыта. Был использован подход, описанный в предыдущем
параграфе. Был зарегистрирован Hook \textit{view\_layouts\_base\_body\_bottom},
позволяющий добавить элементы в конец HTML секции \textit{body}. В
соответствующий шаблон частичного представления был добавлен следующий код:
\small{\begin{lstlisting}
<% if @page.private? %>
  <span class="private">Private</span>
<% end %>
\end{lstlisting}}
На первой строке if-условие определяет, является ли страница закрытой и в
случае успеха на второй строке происходит размещение элемента \textit{span},
служащего идикатором закрытости.

Элемент \textit{span} был размещён в конце страницы и необходимо переместить
данный элемент в наиболее заметное место, таким образом, чтобы не нарушался
общий стиль интерфейса. Подобное действие возможно произвести с помощью
исполнения javascript кода, модифицирующего дерево DOM:
\small{\begin{lstlisting}
$$('.contextual')[0].insert({top:$$('span.private')[0]})
\end{lstlisting}}
В Redmine используется javascript фреймворк Prototype, добавляющий
дополнительные функции для работы с деревом DOM. Функции
\textit{\$\$('.contextual')[0]} и \textit{\$\$('span.private')[0]} производят
поиск элементов по селекторам и возвращают первый из найденных элементов.
Селектор \textit{span.private} выбирает элемент, являющийся индикатором
закрытости, а селектор \textit{contextual} выбирает панель, в которой
расположены элементы управления вики-страницей. Функция \textit{insert}
помещает индикатор закрытости в панель управления вики-страницей.

Последним шагом было произведено добавление элемента, с помощью которого,
пользователь будет изменять закрытость страницы.
\small{\begin{lstlisting}
<%= link_to_if_authorized(l(:button_hide_wiki),
  {:action => 'change_privacy', :id => @page.title, :private => 1}, :method =>
  :post, :class => 'icon icon-hide') if !@page.private? %>
\end{lstlisting}}
Helper \textit{link\_to\_if\_authorized} создаёт ссылку, посылающую post
запрос, адресованный методу \textit{change\_privacy} в контроллере
\textit{wiki}, с параметром \textit{private} равным 1. То есть при вызове
данной ссылки вики-страница изменит статус на закрытый. Создание данной ссылки
происходит только в том случае, если страница открыта и у текущего пользователя
есть соответствующие права доступа. Созданная ссылка была размещена в панеле
управления вики-страницей с помощью техники, описанной в предыдущем абзаце.
Аналогичным образом была создана и размещена ссылка, изменяющая статус
вики-страницы на открытый.

\subsection{Результат}
В параграфе \ref{section:private_wiki} была рассмотрены основные этапы создания
плагина, а также было приведено краткое описание используемых механизмов.
Результатом разработки стал плагин, добавляющий следующую функциональность:
\begin{itemize}
  \item элемент, позволяющий изменять видимость вики-страницы;
  \item индикатор, указывающий на то, что вики-страница является закрытой;
  \item контроль прав доступа на просмотр закрытых вики-страниц;
  \item контроль прав доступа на изменения статуса закрытости вики-страницы.
\end{itemize}

\section{Ограничение доступа к репозиториям}
Требования к плагину указаны в пункте \ref{definiton:private_repository}.
Разработка плагина была разбита на несколько этапов:
\begin{itemize}
  \item Добавление в представление элемента изменяющего закрытость репозитория;
  \item Локализация всех местах, где отображается информация, связанная с
  репозиторием;
  \item Добавление проверки на приватность в местах связанных с
  информацией о репозитории.
\end{itemize}

При помощи механизма миграции, описанного в параграфе \ref{section:migration},
в таблицу, хранящую иноформацию о репозитории, был добавлен флаг \textit{is\_private},
хранящий статус открытости репозитория. Далее была найдена страница, на которой
производится изменения свойств репозитория. Форма со свойствами репозитория
располагается в административной панели проекта и генерируется с помощью
Helper'a \textit{repository\_field\_tags}. При помощи средств метапрограммирования
данный метод был изменён:
\small{\begin{lstlisting}
def repository_field_tags_with_private_repository(form, repository)
repository_field_tags_without_private_repository(form, repository) +
  content_tag('p', form.check_box(
      :is_private,
      :label => l(:field_is_private)
  ))
\end{lstlisting}}
Метод \textit{content\_tag} создаёт тег \textit{<p>} внутри которого будет
сгенеририрован флаг привязанный к свойству \textit{is\_private} у формы. За
сохранение и отображения \textit{is\_private} свойства отвечает механизм форм
Rails приложения.
Благодаря механизму Helper'ов на форму свойств репозитория было добавлено флаг,
управляющий закрытостью.

Было произведёно изучение внутренней работы Redmine и выявлены следующие места
в интерфейсе, в которых возможно отображение информации о репозиториях:
\begin{itemize}
  \item вкладка с репозиторием;
  \item вкладка, отображающая активность проекта;
  \item ссылки на коммит в вики-странице;
\end{itemize}
В функционале данного интерфейса проверка прав доступа реализована двумя
разными способами: через метод \textit{allowed\_to}, упомянутый в параграфе
\ref{section:access_control}, и через конструирование SQL запроса. Изменение
второго метода, без полной его замены, не представляется возможным в следствии
сложной внутренней структуры: метод не разбит на подметоды и к тому же содержит
порядка десяти if-условий, в том числе вложенных.

В Redmine предусмотрено два вида прав доступа к репозиторию:
\textit{browse\_repository} и \textit{view\_changesets}.
\textit{browse\_repository} позволяет видеть файлы в репозитории, a
\textit{view\_changesets} изменения репозитория, то есть коммиты.
Проверка вышеназванных прав доступа была изменена с учётом закрытых
репозиториев:
\small{\begin{lstlisting}
def allowed_to_with_private_repository?(action, context, options={}, &block)
  if (:browse_repository == action || :view_changesets == action) &&
        context.repository.is_private 
      return allowed_to?(:view_private_repositories, context, options,
      &block)       
  end
end
\end{lstlisting}}
При условии, что проверяемое право доступа \textit{action} сопадает с
перехватываемыми (\textit{browse\_repository } и \textit{view\_changesets}) и
репозиторий является закрытым, производится проверка на право доступа к
закрытым репозиториям \textit{view\_private\_repositories}, которое было
создано как указано в п.\ref{section:access_control}. Таким образом
вкладка с закрытым репозиторием стала недоступной для пользователей, без
соответсвующих прав.


\section{Рассылка уведомлений о задачах}
В соответствии с требованиями указанными в
п.\ref{definition:due_date_reminder}, плагин должен реализовывать следующий
функционал:
\begin{itemize}
  \item конфигурирование настроек через пользовательский интерфейс;
  \item уведомления пользователей в указанные дни;
  \item уведомление с общим список просроченных и приближающихся задач; 
  \item принудительное уведомление о просроченных задачах раз в сутки;
\end{itemize}
Разработка плагина была разбита на две части: модификация пользовательского
интерфейса и разработка модуля, отвечающего за рассылку задач.

В постановке задачи указано, что пользователь должен иметь возможность
настройки параметров уведомление, следовательно необходимо добавить поле,
определяющее частоту уведомлений. В БД было добавлено поле
\textit{reminder\_notification} в таблицу \textit{users}. Данное поле
предназначено для хранения строки, в которой содержатся числа, записанные через
запятую и отвечающие за то, в какие дни пользователь должен быть уведомлен о
приближающихся задачах. К примеру значение поля \textit{1,3,5} указывает, что
необходимо уведомить пользователя за 1, за 3 и за 5 дней до окончания срока
задачи. При помощи Hook'ов было добавлено поле \textit{reminder\_notification}
на форму редактирования настроек пользователя.
\inspicture{reminder-settings}{Страница пользовательских настроек}{0.8}
Формат поля не имеет ограничений на вводимые данные, поэтому были созданы
методы, отвечающие за валидацию:
\small{\begin{lstlisting}
def self.valid_reminder_notification?(value)
  value =~ /\A(\d+[\s,]*)+\z/
end
\end{lstlisting}}
Данный метод возвращает \textit{true}, если значение \textit{value}
набором чисел, разделённых запятой. Следующим шагом было внесено
изменение в метод контроллера, сохраняющего данные с формы настроек:
\small{\begin{lstlisting}
def check_reminder_input
  if !User.valid_reminder_notification?(params[:user][:reminder_notification])
    flash[:error] = l(:error_reminder_notification_input) return redirect_to
    :action => 'account'
  end
end
\end{lstlisting}}
Во второй строке производится проверка, является ли параметр
\textit{reminder\_notification} правильного формата.
Если параметр не соответствует формату, то во второй строке сохраняется
сообщение об ошибке, для последующего вывода пользователю и на последней
строке происходит перенаправление на текущую страницу, с  целью обновеления
представления. Таким образом была создана возможность редактирования
параметров уведомления с помощью поля, отображенного на рисунке
\ref{picture:reminder-settings}.

Рассылка уведомлений включает в себя действия, показанные на рисунке 
\ref{picture:reminder-plugin}. Данная функциональность была инкапсулирована
соответсвующие методы класса \textit{ReminderMailer}.
\inspicture{reminder-plugin}{}{0.4}

Получение задач из БД было реализовано с помощью SQL запроса, который выбирает
задачи по нескольким критериям:
\small{\begin{lstlisting}
"#{IssueStatus.table_name}.is_closed = ?", false]
"#{Issue.table_name}.due_date IS NOT NULL"
"#{Project.table_name}.status = #{Project::STATUS_ACTIVE}"
"#{Issue.table_name}.assigned_to_id IS NOT NULL"
"#{User.table_name}.status = #{User::STATUS_ACTIVE}"
\end{lstlisting}}
Задача не закрыта, у неё уставлен срок сдачи и она располагается в активном
проекте. У задачи есть ответсвенный пользователь и он является активным.
\small{\begin{lstlisting}
def self.find_issue
  issues.reject! { |issue| not (issue.remind? or issue.overdue?) }
  issues.sort! { |first, second| first.due_date <=> second.due_date }
end
\end{lstlisting}}
В issues хранятся задачи, полученные, с помощью вышеобозначенного запроса. Во
второй строке отфильтровываются задачи и в массиве issues остаются только те,
о которых необходимо уведомлять или срок сдачи которых прошёл. В последней
строке производится сортировка по сроку сдачи. Класс Issue был расширен двумя
методами, для того, чтобы была возможна фильтрация, описанная во второй строке:
\small{\begin{lstlisting}
def days_before_due_date
  (due_date - Date.today).to_i
end
\end{lstlisting}}
В данном методе вычисляются дни оставшиеся до срока сдачи задачи.
\small{\begin{lstlisting}
def remind?
   !assigned_to.nil? and
    assigned_to.reminder_notification_array.include?(days_before_due_date)
end
\end{lstlisting}}
Если у задачи нет ответственного, то о ней не нужно уведомлять. В противном
случае у ответственного пользователя получается список дней в которые
следует его уведомлять и происходит проверка необходимости уведомления в
сегодняшний день.


Класс ReminderMailer был унаследован от класса Mailer, для того, чтобы добавить
возможности отсылки писем и их генерации на основе ERB шаблонов. Метод
производящий отсылку уведомлений выглядит следующим образом:
\small{\begin{lstlisting}
def self.send_due_date_notifications
  issues = self.find_issues
  issues.each { |issue| self.insert(data, issue) }
  data.each do |user, projects|
    deliver_due_date_notification(user, projects)
  end
end
\end{lstlisting}}
На второй строке выбирается все задачи, с помощью описанного выше метода. В
третьей строки полученные данные группируются в двухуровневую хеш-таблицу, где
ключами первого уровня являются пользователи, а ключами второго уровня проекты,
значениями которых являются отсортированные задачи. Метод
deliver\_due\_date\_notification формирует письмо для каждого из
пользователей и передаёт данные хеш-таблицы в ERB шаблон. 


\section{Изображения-ссылки в боковой панели}
Задача состоит, чтобы разместить ссылки в боковой панели, которые будут
указывать на рекомендуемые ресурсы. Усовершенствование было выполнено в виде
плагина, поскольку система Hook'ов Redmine, описанная в параграфе
\ref{section:redmine_hooks}, позволяет внести изменения в боковую панель
способом, предусмотренным разработчиками Redmine. Была произведена регистрация
Hook'a \textit{view\_layouts\_base\_sidebar} и создано частичное представление,
в который были помещены ссылки на три ресурса. Результат работы отображён на
рисунке \ref{picture:sidebar-links}, в котором боковая панель находится в
правой части под надписью ``We Recommend''.
\inspicture{sidebar-links}{Изображения-ссылки в боковой панели}{0.7}


\section{Механизм позиционирования календаря}
Для выбора дат в Redmine присутсвует элемент Календарь. При открытии календаря
на устройствах с низким разрешением экрана он может разместиться за границами
экрана, что создаёт неудобства при его использовании. На рисунке
\ref{picture:calendar-not-visible} показан календарь выехавший за границы
экрана. Исправить подобный дефект возможно с помощью стандартной javascript
функции \textit{scrollTo}. Данная функция позволяет программно проскроллить
страницу в место с указанными координатами. Координаты назначения, в которые
необходимо проскроллить страницу, были вычислены при помощи функций,
возвращающих координаты видимой области окна и положение календаря.
\inspicture{calendar-not-visible}{Календарь расположен за границами окна}{0.7}

Подобное решение обладает недостатком: скроллинг происходит мгновенно и
пользователь будет вынужден вновь искать на странице календарь, что является не
лучшим решением с точки зрения пользовательского интерфейса. Было произведено
усовершенствование, позволяющее сделать скроллинг страницы плавным.
Библиотека Prototype, поставляемая с Redmine, предоставляет функции,
обеспечивающие возможность создания анимации. В рамках задачи, интерес
предоставляют две функции \textit{Effect.Parallel} и \textit{Effect.Tween}.
Было создано две функции \textit{Tween}, производящие плавное скроллирование до
указанной точки по оси ординат и по оси абсцисс. Эффекты были применены
параллельно с помощью функции \textit{Parallel}.

Механизм позиционирования был выполнен в виде патча, исходный код которого
помещён в приложение \ref{appendix:ensure-that-calendar-is-visible.patch}.

\section{Возможность указать тип задачи при составлений обзора кода}

\section{Расширение интеграции с системами контроля версий}









%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "diploma"
%%% End:
