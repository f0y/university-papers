\lstset{language=Ruby}

\chapter{Реализация расширений}

\section{Ruby on Rails}
Ruby on Rails "--- это фреймворк для построения веб-приложений в соответствии с
шаблоном проектирования Модель-Вид-Контроллер (MVC). Rails приложение состоит
из трёх ключевых уровней.

Уровень представления состоит из файлов-шаблонов, которые отвечают за
отображение данных приложения. Шаблоны могут быть различных видов, но основной
формат "--- это HTML со вставками на языке Ruby, за генерацию которого отвечает
движок ERB языка Ruby.

Уровень модели представляет доменную область и инкапсулирует бизнес-логику
приложения. Классы модели в Rails приложении могут быть связаны с базой данных
(БД) через ActiveRecord. ActiveRecord даёт возможность работать со строками в
БД как с обычными объектами, а также дополнять эти объекты методами
бизнес-логики.

Контроллеры отвечают за обработку входящих HTTP запросов и формирование ответа.
Зачастую, ответ возвращается в HTML, но также возможна генерация ответа в XML,
JSON, PDF и других форматах. Контроллеры генерируют ответ на основе данных,
полученных из моделей, и соответствующих шаблонов представления.
% временное изображение, будет что-то похожее.
\inspicture{rails-architecture}{Архитектура Rails приложения}{1}

\subsubsection{Структура Rails приложения}
Rails приложение организовано в нескольких директорий, предназначенных для
хранения следующих компонентов:
\begin{itemize}
\item app/controllers: классы контроллеров;
\item app/helpers: вспомогательные (Helper) классы для шаблонов представления,
моделей и контроллеров;
\item app/models: классы модели;
\item app/view: шаблоны представления;
\item app/view/layouts: макеты для шаблонов представления;
\item config: конфигурация приложения, в том числе конфигурация БД и различных
окружений;
\item db: данные связанные с БД, к примеру схема БД и файлы миграции;
\item lib: библиотеки и различные файлы с классами;
\item public: статические данные: javascript, css, HTML файлы и изображения;
\item script: файлы скриптов для запуска различных инструментов;
\item test: классы, предназначенные для тестирования приложения;
\item vendor: сторонние библиотеки.
\end{itemize}
В папке vendor/plugins содержатся плагины Redmine. Структура директории с
плагином во многом схожа с Rails, поскольку плагин является миниатюрным Rails
приложением. Директория плагина включает папки, содержание которых
было описано выше: app, db, config, test, lib. А также папка assets, назначение
которой соответствует директории public.


\section{Ограничение доступа к отдельным вики-страницам}
В данном пункте детально описана реализация плагина,
предоставляющего функционал в соответсвии с требованиями, опеределёнными
в пункте \ref{definition:private_wiki}.

\subsection{Регистрация плагина}
Redmine регистрирует плагин, получая информацию из файла init.rb, находящегося
в директории /vendor/plugins/redmine\_<имя\_плагина>. Плагин был назван
private\_wiki и соответвенно была создана соответствующая директория с файлом
init.rb следующего содержания:

\small{
\begin{lstlisting}
Redmine::Plugin.register :redmine_private_wiki do
  name 'Private Wiki'
  author 'Oleg Kandaurov'
  description 'Adds private pages to wiki'
  version '0.0.1'
end
\end{lstlisting}}

Redmine::Plugin.register "--- функция, которая производит регистрацию плагина
под именем redmine\_private\_wiki. На остальных строках указана информация о
плагине:
\begin{itemize} 
  \item name: имя плагина, отображаемое пользователю;
  \item author: имя автора плагина;
  \item description: краткое описание плагина;
  \item version: версия плагина.
\end{itemize}

\subsection{Миграция базы данных} 
Механизм миграции "--- это часть Rails модуля ActiveRecord, при помощи которого
разработчикам предоставляется удобный доступ изменения БД. Главное преимущество
механизма миграции, что он не зависит от БД, поскольку трансформации
записываются используя специальный формат. Файл миграции могут быть применены к
БД с помощью запуска команды rake db:migrate. Благодаря механизму миграции
возможно использование различных БД для разных сред, к примеру, SQLite3 для
разработки и MySQL для тестовой среды. Разработчики Redmine предусмотрели
возможность использования механизма миграции плагинами.

В БД должна храниться информация о том является страница закрытой или нет. То
есть необходимо определить место для хранения данной информации и
соответсвующим образом изменить БД. Путём изучения БД было выявлено, что данные
о вики-странице хранятся в таблице wiki\_pages. Было принято решение, добавить
в вышеназванную таблицу дополнительный столбец, определяющий закрытость
страницы. Для изменения БД был использовован механизм миграции. Данные о
миграции были размещены в файле db/migrate/0001\_add\_private\_wiki.rb со
следующим содержанием:

\small{
\begin{lstlisting}
class AddPrivateWiki < ActiveRecord::Migration
  def self.up
    add_column(:wiki_pages, "private", :boolean, :default => false)
  end
  def self.down
    remove_column(:wiki_pages, "private")
  end
end
\end{lstlisting}}
Класс миграции должен быть унаследован от ActiveRecord::Migration, а также в
нём должны быть определены два метода: up и down. Первый метод описывает
действия при применении миграции, а второй при её отмене. При применении
миграции осуществляется добавление столбца private, имеющего boolean тип, в
таблицу wiki\_pages. А при отмене миграции столбец private будет удалён из
таблицы wiki\_pages. Применение миграции осуществляется с помощью вызова
команды rake db:migrate\_plugins.

\subsection{Система контроля доступа}
\label{section:access_control}
Redmine предоставляет гибкую систему контроля доступа на основе ролей. Роль
включает в себя определённое количество прав доступа, которые сгруппированы в
соответствии с назначением, по модулям. Гибкость заключается в том, что
администраторы имеют возможность создавать дополнительные роли, а также
назначать пользователю разные роли в зависимости от проекта.

В рамках решаемой задачи, необходимо создать право доступа определяющее
видимость закрытых страницам. Системой плагинов Redmine предусмотрена
возможность регистрации дополнительных прав доступа. Следующие изменения были
внесены в файл init.rb:

\small{
\begin{lstlisting}
project_module :wiki do
  permission :view_private_wiki_pages, {}
end
\end{lstlisting}}
Метод project\_module :wiki добавляет нижестоящее право доступа в модуль wiki.
Во второй строке определяется новое право доступа с именем
view\_private\_wiki\_pages.  


\subsection{Расширение классов во время выполнения}
\label{section:metaprogramming} 
Метапрограммирование "--- это процесс написание компьютерных программ,
способных создавать и изменять другие программы или самих себя на этапе
компиляции или во время выполнения. Ruby "--- динамический язык, который
предоставляет широкие возможности для метапрограммирования. В частности,
приложения на Ruby могут программно изменять свою структуру во время
выполнения. Метапрограммирование в Ruby может использоваться для следующих
целей:
\begin{itemize}
  \item модификация методов и перехват вызовов;
  \item генерация классов и методов по параметрам;
  \item автоматическая сериализация;
  \item интерактивная помощь.
\end{itemize}

Задача заключается в том, чтобы изменить бизнес-логику, связанную с проверкой
доступа к вики-страницам. Право доступа, отвечающее за видимость вики-страниц
называется view\_wiki\_pages. В бизнес-логике вышеназванное право доступа
используется в классе WikiPage в методе visible?:

\small{
\begin{lstlisting}
def visible?(user=User.current)
  !user.nil? && user.allowed_to?(:view_wiki_pages, project)
end
\end{lstlisting}}
Метод allowed\_to? класса User проверяет наличие у пользователя права на
просмотр вики-страниц в заданном проекте. Стало возможным сформулировать
задачу точнее: требуется с помощью возможностей метапрограммирования изменить
поведение метода visible? в классе WikiPage таким образом, чтобы дополнительно
у пользователя проверялось право доступа на просмотр закрытых страниц.

\subsubsection{Расширение классов во время выполнения} 
Один из способов изменить поведение класса "--- расширить его с помощью модуля.
Модуль представляет собой набор методов и констант.
Класс может быть расширен путём вызова метода include, в параметрах которого
содержится модуль для расширения. Разработчики Redmine советуют выполнять
расширение в функции обратного вызова to\_prepare в классе Dispatcher. Функция
to\_prepare вызывается единожды при запуске приложение или при каждом запросе,
в зависимости от того, в каком режиме запущено приложение. Код, осуществляющий
расширение, был помещён в файл init.rb:

\small{
\begin{lstlisting}
require 'private_wiki/wiki_patch'
require 'dispatcher'
Dispatcher.to_prepare :redmine_private_wiki do
  unless WikiPage.included_modules.include? PrivateWiki::WikiPatch
    WikiPage.send(:include, PrivateWiki::WikiPatch)
  end 
end
\end{lstlisting}}
В первых двух строках производится подключение файлов с модулем для расширения
и с классом Dispatcher cоответсвенно. Dispatcher.to\_prepare регистрирует
функцию обратного вызова. На следующей строке идёт проверка, недопускающая
повторное включение модуля. И на пятой строке производится включение модуля
PrivateWiki::WikiPatch в класс WikiPage.

Модуль был размещён в файле private\_wiki/wiki\_patch:
\small{
\begin{lstlisting}
module PrivateWiki
  module WikiPatch
    def self.included(base)
      base.send(:include, InstanceMethods)
      base.class_eval do
      end
    end
    module InstanceMethods
    end
  end
end
\end{lstlisting}}
Метод included вызывается при включении модуля в класс, в параметр base
которого будет помещён расширяемый класс. base.send(:include, InstanceMethods)
расширяет класс модулем, методы которого будут доступны экземплярам
расширяемого класса, а методы размещенные внутри блока base.class\_eval могут
быть вызваны на классе.


\subsubsection{Перехват вызовов метода}
Модуль ActiveSupport содержит метод alias\_method\_chain, позволяющий
перехватывать обращение к заданному методу. Рассмотрим его работу на следующем
примере:
\small{
\begin{lstlisting}
base.class_eval do
  alias_method_chain :visible?, :private_wiki
end
\end{lstlisting}}
% Следующее лучше показать картинкой.
При вызове alias\_method\_chain создаётся метод
visible\_without\_private\_wiki в классе WikiPage. Данный метод, осуществляет
проброс вызова на оригинальный метод visible?. А обращение к методу visible?
перенаправляет вызывающего на метод visible\_with\_private\_wiki. Поскольку
метода visible\_with\_private\_wiki не существует, он был создан.
\small{
\begin{lstlisting}
module InstanceMethods
  def visible_with_private_wiki?(user)  
    if self.private and !is_private_page_visible?(project, user)
      return false
    end
    visible_without_private_wiki?(user)
  end
end
\end{lstlisting}}
If-условие производит проверку, если страница является закрытой и пользователь
не имеет прав на просмотр скрытых страниц, то метод возвращает false, в
противном случае вызывается оригинальный метод visible?. Таким образом были
внесены изменения в логику проверки видимости вики-страниц в соответствии с
требованиями.

\subsection{Маршрутизация}
Запрос, поступающий в Rails приложение проходит несколько стадий
обработки. В начале запрос попадает в сервер приложений, который
незамедлительно возвращает ответ, если запрашивается статический файл, а в
противном случае перенаправляет запрос в Dispatcher. Dispatcher производит
разбор входящего запроса и на основе таблицы маршрутизации перенаправляет его в
соответствующий контроллер. Контроллер генерирует ответа на основе
шаблонов вида. После окончания работы контроллера, Dispatcher отправляет ответ
инициатору запроса.

Для контроля необходим определить определить контроллер
обрабатывающий запрос на отображение вики страницы. Вики-страница под именем
`page 1`, в проекте под именем `my\_project` имеет следующий адрес
projects/my\_project/wiki/page\_1. Контроллер, обрабатывающий данный запрос,
может быть опеределён на основе таблицы маршрутизации, вызываемой по команде
rake routes (в выводе опущена несущественная часть):
\small{\begin{lstlisting}
GET    /projects/:project_id/wiki       {:action=>"show", :controller=>"wiki"}
GET    /projects/:project_id/wiki/index {:action=>"index", :controller=>"wiki"}
GET    /projects/:project_id/wiki/:id   {:action=>"show", :controller=>"wiki"}
PUT    /projects/:project_id/wiki/:id   {:action=>"update", :controller=>"wiki"}
DELETE /projects/:project_id/wiki/:id   {:action=>"destroy", :controller=>"wiki"}
\end{lstlisting}}
Первый столбец указывает на тип HTTP запроса, а второй опеределяет формат
адресной строки. На основе этих параметров Dispatcher выбирает метод
контроллера, указанный в третьем столбце, в который будет перенаправлен запрос.
Легко заметить, что в данном случае, за генерацию запроса отвечает метод show в
контроллере под именем wiki. Rails активно использует конвенции по именованию.
Из этих конвенций следует, что класс контроллера должен называться
WikiController и распологаться в директории /app/controllers.

\subsubsection{Добавление маршрута}
В соответствии с требованиями, на вики-странице должен располагаться элемент
отвечающий за скрытие/открытие вики-страницы. Элемент должен посылать запрос,
который будет изменять состояние страницы, а значит необходимо добавить
маршрут, по которому будет идти запрос. Для этого был создан файл
config/routes.rb со следующим содержанием:
\small{
\begin{lstlisting}
ActionController::Routing::Routes.draw do |map|
  map.resources :projects do |project|
    project.private_wiki_change_privacy
        'wiki/:id/change_privacy/:private',
        :controller => 'wiki', :action => 'change_privacy',  :conditions =>
            {:method => :post}
  end
end
\end{lstlisting}}
В первой и второй строке В третьей строке создаётся маршрут под названием
private\_wiki\_change\_privacy. И в следующих строках указывается, что запрос,
адрес назначения которого соответствует шаблону
wiki/:id/change\_privacy/:private, следует перенаправить в контроллер c
именем wiki в метод change\_privacy. Следует заметить, что :private и :id
являются параметрами, которые доступны в переменной params в контроллере.

\subsubsection{Запрещение доступа к вики-странице}
Для того, чтобы скрытая вики-страница не отображалась пользователям без
соответствующих прав, выполним перехват вызова метода show в контроллере
WikiController, с помощью техник, описанных в параграфе
\ref{section:metaprogramming}:
\small{
\begin{lstlisting}
def show_with_private_wiki
  if not @page.visible? {return render_403}
  show_without_private_wiki
end
\end{lstlisting}}
На второй строке указано, что если просматривая страница должна быть скрыта от
пользователя, то следует производить вывод сообщение о том, что доступ к
странице закрыт. Третья строка выполняет, а оригинальный метод show.

Следующий шаг заключается в создании метода change\_privacy, который будет
отвечать за смену статуса вики-страницы:
\small{
\begin{lstlisting}
def change_privacy
  find_existing_page
  @page.update_attribute :private, params[:private]
  redirect_to :action => 'show', :project_id => @project, :id => @page.title
end
\end{lstlisting}}
Во второй строке происходит вызов метода, который выполняет различные проверки
и присваивает переменной @page объект, связанный с текущей вики-страницей и
привязанный к БД. На третьей строке объекту устанавливается атрибут private,
полученный из запроса, таким образом изменения заносятся в БД. На последней
строке происходит перенаправление в метод контроллера, отвечающий за
отображение вики-страницы.

На данном этапе пользователь с любыми правами имеет возможность изменить
закрытость страницы. В требованиях указано, что только пользователи с
определёнными правами должны иметь право изменять закрытость страницы. В связи
с этим было добавлено дополнительное право доступа:
\small{\begin{lstlisting}
permission :manage_private_wiki_pages, {:wiki => :change_privacy}
\end{lstlisting}}
:wiki => :change\_privacy указывает на то, что только пользователи с данным
правом доступа имеют возможность вызывать метод change\_privacy в контроллере
wiki.

\subsection{Redmine Hooks}
Redmine поддерживает концепцию Hook'ов. Hook "--- это API, который позволяет
расширить функциональность Redmine. При помощи Hook'a автор имеет возможность
зарегистрировать функции обратного вызова, которые будут вызваны одна за
другой, при достижении участка кода, в котором расположен Hook. В документации
Redmine есть список Hook'ов, но он не полный и авторы Redmine советуют
разработчикам самостоятельно просмотреть интересующую часть кода на предмет
наличия в ней Hook'ов. При достижении Hook'a Redmine исполняет
зарегистрированные функции обратного вызова. Функции содержат только один
параметр "--- хэш, содержащий информацию о контексте вызова Redmine
предоставляет три вида Hook'ов: для шаблонов представления, модели и
контроллеров. Разработчики Redmine советуют использовать вместо двух последних
видов Hook'ов механизмы фреймворка Ruby On Rails и языка Ruby, рассмотренные
в параграфе \ref{section:metaprogramming}. 

Контекст, передаваемый в Hook шаблона представления содержит следующие данные:
\begin{itemize}
  \item controller: ссылка на контроллер который производит генерацию
  текущего шаблона представления;
  \item project: текущий проект, если таковой установлен контроллером;
  \item request: объект, содержащий информацию о веб-запросе;
  \item дополнительные параметры, специфичные для Hook'a, которые могут
  быть найдены в вызове метода call\_hook на шаблоне представления.
\end{itemize}
Значение, возвращаемое зарегестрированной функцией обратного вызова,
преобразуется в строку и встраивается в представление. Таким образом механизм
Hook'ов позволяет встраивать HTML-код в места, определённые расположением
соответствующего Hook'а.

\subsubsection{Создание Hook'а для подключения CSS стилей}
Элементы, которые будут распологаться на вики-странице должны иметь оформление,
описанное в файле с CSS стилем. Необходимо определить местонахождение шаблона
представления. Приводится код метода show  класса WikiController(несущественная
часть опущена).
\small{\begin{lstlisting}
def show
  render :action => 'show'
end
\end{lstlisting}}
render :action => 'show' указывает на то, что генерируемый шаблон представления
называется show. В соответствии с конвенциями именования, его следует искать в
директории /app/views/wiki\_controller в файле show.html.erb.
Вызовы метода call\_hook в шаблоне отсутсвуют, следовательны Hook'и специфичные
для данного представления отсутствуют и следует искать глобальные Hook'и,
присутствующие на всех страницах. Все шаблоны представления в Redmine
генерируются внутри главного макета, находящегося в файле
/app/views/layouts/base.html.erb. В данном макете, определены несколько
Hook'ов, в следующих местах страницы:
\begin{itemize}
  \item view\_layouts\_base\_html\_head: внутри HTML секции head ;
  \item view\_layouts\_base\_sidebar: в боковой панели;
  \item view\_layouts\_base\_content: в главной области страницы; 
  \item  view\_layouts\_base\_body\_bottom: в конце HTML секции body.
\end{itemize}
Из перечисленных Hook'ов, для подключения CSS-стиля подходит
view\_layouts\_base\_html\_head. В файле lib/private\_wiki/hooks.rb был
зарегестрирован Hook и создана функция обратного вызова.
\small{\begin{lstlisting}
class PrivateWikiHook < Redmine::Hook::ViewListener
  render_on :view_layouts_base_html_head, :partial => 'hooks/html_header'
end
\end{lstlisting}}
Redmine::Hook::ViewListener "--- класс, регистрирующий Hook'и render\_on
регистрирует функцию обратного вызова, которая генерирует частичный шаблон
представления с именем hooks/html\_header при вызове Hook'а
view\_layouts\_base\_html\_head.

В соответствии с конвенциями именования, частичный шаблон представления,
упомянутый выше, должен располагаться в файле
app/views/hooks/\_html\_header.html.erb:
\small{\begin{lstlisting}
<% if controller and
  controller.class.name == 'WikiController' and
  controller.action_name == "show" %>
    <%= stylesheet_link_tag "private_wiki.css",
      :plugin => "redmine_private_wiki",
      :media => "screen" %>
<% end %>
\end{lstlisting}}
В первых трёх строках указано, что подключение стиля следует выполнять только
если процесс генерации страницы был инициирован контроллером WikiController и
методом show. Подключение файла с CSS стилем осуществляется с помощью Helper'а
stylesheet\_link\_tag. Механизм Helper'ов позволяет выделить повторяющийся код
в методы и получить преимущества от многократного использования кода. В Helper
передаются несколько параметров указывающих, расположение файла стиля. В
данном случае файл c CSS стилем должен быть расположен в директории
assets/stylesheets/private\_wiki.css.

\subsubsection{Создание Hook'а для размещения элементов}




\section{Улучшенный механизм позиционирования всплывающего календаря}

\section{Возможность указать тип задачи при составлений обзора кода}

\section{Улучшенная система навигации между страницами просмотра изменений}
% Патч такой-то исходный код в приложении
% ~\ref{appendix:back-link-to-rev-from-diff.patch})

\section{Расширение интеграции с системами контроля версий}

\section{Рассылка уведомлений о приближающихся и просроченных задачах}

\section{Ограничение доступа к репозиториям}

\section{Изображения-ссылки в боковой панели}



%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "diploma"
%%% End:
